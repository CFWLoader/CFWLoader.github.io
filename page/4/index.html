<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>CFWLoader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="It&#39;s interesting to solve problems by coding.">
<meta property="og:type" content="website">
<meta property="og:title" content="CFWLoader">
<meta property="og:url" content="https://cfwloader.github.io/page/4/index.html">
<meta property="og:site_name" content="CFWLoader">
<meta property="og:description" content="It&#39;s interesting to solve problems by coding.">
<meta property="og:locale" content="zh_ZN">
<meta property="article:author" content="Evan Huang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="CFWLoader" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CFWLoader</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">A man who codes for fun.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cfwloader.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TCP基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/12/TCP%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2017-12-12T07:31:01.000Z" itemprop="datePublished">2017-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/12/TCP%E5%9F%BA%E7%A1%80/">TCP基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>Java后台开发</code>一般要求的知识是掌握一些开发技能，一般是从<code>SSH</code>框架，问问项目，有些注重基础能力的，就会往<code>Java SE</code>方面问，例如<code>HashMap</code>，<code>Object</code>类有几个方法，虚拟机，垃圾回收机制等。大公司会考察分布式应用知识作为加分项，如<code>Hadoop</code>、<code>MapReduced</code>等。</p>
<p>笔者当年对<code>C++后台开发</code>有错误的认知，认为与Java的要求大约一致，仅仅要求开发技能，也没有到网上搜索攻略，到了真正跑招聘的时候才发现这个岗位除了一般<code>C++</code>知识基础外，还要求有<code>Linux</code>系统操作知识(常用命令在内)、<code>TCP/IP</code>通信基础、<code>Socket</code>开发经验等。其中<code>TCP</code>的要求如下图:</p>
<p><img src="/2017/12/12/TCP%E5%9F%BA%E7%A1%80/o_tcpsm.jpg"></p>
<p>但是这个图背诵起来也不容易，总结一下主要考察的是<code>3次握手</code>、<code>4次挥手</code>。</p>
<p>三次握手的流程:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.server先初始化好了一个监听用的socket，server进入了LISTEN状态;</span><br><span class="line">2.客户端发起了TCP连接，向server发送了一个SYN，进入SYN_SENT状态;</span><br><span class="line">3.server接收到了来自客户端的SYN，向发起请求的客户端发送SYN+ACK，进入SYN_RCVD状态;</span><br><span class="line">4.客户端接收到了server返回的SYN+ACK信号，发送ACK信号给server，进入ESTABLISHED状态;</span><br><span class="line">5.server接收到了ACK，进入ESTABLISHED状态。</span><br></pre></td></tr></table></figure>
<p>整个三次握手的文本描述过程就是这样。</p>
<p>四次握手的客户端状态转换则有点麻烦，主要与server返回FIN和ACK的顺序有关。</p>
<p>（待续）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/12/TCP%E5%9F%BA%E7%A1%80/" data-id="clximfz6s00257kkv1jum71cb" data-title="TCP基础" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Effective-C-五" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/11/Effective-C-%E4%BA%94/" class="article-date">
  <time class="dt-published" datetime="2017-12-11T08:58:47.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/11/Effective-C-%E4%BA%94/">Effective C++(五)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前面探讨了<code>C++</code>中构造、析构以及赋值方面的问题，随后书上第三个主题就开始是<code>资源管理</code>。在当前流行的<code>Java</code>、<code>Python</code>等语言中，甚至早期的<code>Scheme</code>也有<code>垃圾回收(Garbage Collection, GC)</code>机制。使用者只需要在需要新的对象的时候用<code>new</code>语义创建对象实例，之后就不需要手动用<code>delete</code>语义释放这个对象或考虑对象何时会被释放，完全由运行时环境(虚拟机是运行时环境的子集)决定。</p>
<p>说回<code>C++</code>，因其历史原因等，是几乎不可能让语言集成垃圾回收机制，这样极有可能导致以后版本的编译器无法兼容老旧的代码，甚至造成语言自身分裂成不同的阵容@Python。而且垃圾回收本身也占用系统资源，这对于某些场景(如高频交易)来说，1毫秒的延迟都能造成不小的金融损失。所以<code>C++</code>只能在选择集成垃圾回收机制的以外做抉择。虽然<code>C++11</code>才正式地内建<code>shared_ptr</code>、<code>weak_ptr</code>、<code>scoped_ptr</code>等对象管理指针的方法，其实早在<code>0x</code>时代<code>Boost</code>库就已经做好了这些功能了，所以笔者觉得<code>C++11</code>很大部分就是把<code>Boost</code>中用得多的特性吸收了进来(Effective C++最后一条也是建议熟悉Boost)。</p>
<p>垃圾回收机制的威力不仅仅体现在释放使用者的脑力，使其能够更加专注与业务代码的构建。在现在硬件性能上升以及计算处理量越来越大的年代，<code>多线程(Multithreaind)</code>编程也变得十分常见。在单线程的场景下，使用者可以通过调试和使用一些内存泄漏检测工具(如<code>valgrind</code>)最终得到一个内存管理十分精确的版本。但是在多线程的环境下，前人积累下来的经验毁于一旦，在这个线程某个对象尚未初始化完成，可能就要接受另一个线程的访问;更恐怖的是在这个线程这个对象已经被析构了，但是被另外一个线程访问了。笔者曾经试过写一个多线程的程序，调试了三天，最终发现是某个变量在主线程被析构了，别的线程仍在访问。但是如果不释放一些对象的话，施以<code>互斥锁</code>应该可以解决对象的正确访问问题，但是这样可能程序就不能长久运行了，毕竟系统内存有限。</p>
<p>因此，结合<code>C++11</code>，使用者也可以摆脱手动管理指针的烦恼，再掌握一些良好的多线程编程习惯，多多少少可以减轻多线程编程恐惧。</p>
<h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13:以对象管理资源"></a>条款13:以对象管理资源</h2><p>这个条款，书上首先介绍了<code>资源取得时机便是初始化时机(Resource Acquisition Is Initialization,RAII)</code>，狭义理解为在构造函数中尽可能地使用初始化列表初始化成员。广义上就是资源一分配下来就放入到对象中管理。</p>
<p>在介绍了一个场景之后，就演示了一个用<code>auto_ptr</code>的例子，但是<code>auto_ptr</code>在<code>C++11</code>中被弃用了，用<code>unique_ptr</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">std::unique_ptr&lt;Object&gt; <span class="title">objPtr</span><span class="params">(<span class="keyword">new</span> Object(...))</span></span>;</span><br><span class="line"></span><br><span class="line">	objPtr-&gt;{调用一些成员函数};</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这是一个<code>RAII</code>的样例，fun一开始<code>unique_ptr</code>就申请了一个<code>Object</code>对象并且马上置入到<code>unique_ptr</code>对象中;fun结束之后，<code>unique_ptr</code>对象结束了在其作用域内的寿命，调用了析构函数，而这个析构函数就是<code>delete</code>一个<code>Object*</code>。</p>
<p>当一个对象在多处被引用，其析构的时机当然是在最后一个引用结束之后，但是这样如何得知其最后一个引用是在哪里？这里提出了一个<code>引用计数器</code>的方法，书上称之为<code>引用计数型智慧指针(reference-counting smart pointer, RCSP)</code>。简要的说，一个对象被引用一次，其引用计数就+1，引用其的某个对象结束了生命周期，该对象的引用便-1。当引用计数为0的时候，就释放该对象。但是这里的引用计数其有个<code>循环引用</code>的问题:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cyclesOfReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">shared_ptr&lt;Object&gt; <span class="title">obj1</span><span class="params">(<span class="keyword">new</span> Object(...))</span>, <span class="title">obj2</span><span class="params">(<span class="keyword">new</span> Object(...))</span></span>;</span><br><span class="line"></span><br><span class="line">	obj1-&gt;<span class="built_in">attach</span>(<span class="built_in">shared_ptr</span>&lt;Object&gt;(obj2));			<span class="comment">// 假设attach函数是为对象建立某种关系，引起了引用+1;</span></span><br><span class="line"></span><br><span class="line">	obj2-&gt;<span class="built_in">attach</span>(<span class="built_in">shared_ptr</span>&lt;Object&gt;(obj1));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样在<code>cyclesOfReference()</code>的作用域内，<code>obj1</code>和<code>obj2</code>对象的引用数至少为2;当函数执行结束的时候，各自减了1，引用数至少为1。因为它们的引用数不为0,所以没被析构释放，但是它们再也不起作用了。其它集成了垃圾回收机制的语言中用了<code>可达性分析</code>的方法解决这个问题，在这里暂不展开讨论。</p>
<p>注意<font color="red">unique_ptr</font>和<font color="red">shared_ptr</font>等智能指针在析构的时候对对象用的的<code>delete</code>而不是<code>delete[]</code>，所以很遗憾它们只能管理单个对象。</p>
<p>另外<code>shared_ptr</code>也只能保证对象一定会在引用数为0时被析构，而不能保证对象只会被析构1次。</p>
<p>虽然<code>C++</code>也开始提供对象管理内存的机制，但是方便性不及集成垃圾回收机制的语言，使用者当作是个辅助性的手段就好，决不能依赖。</p>
<h2 id="条款14-在资源管理类中小心copying行为"><a href="#条款14-在资源管理类中小心copying行为" class="headerlink" title="条款14:在资源管理类中小心copying行为"></a>条款14:在资源管理类中小心copying行为</h2><p>对于该条款，笔者的理解是有些资源是不能共享的，大约是现在笔者已经过了入门时期，自然而然地觉得对象设计根据场景就能得出对象该如何设计，例如书上举例的互斥锁:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm)</span></span><br><span class="line"><span class="function">	{</span></span><br><span class="line">		<span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Lock</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">unlock</span>(mutexPtr);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>原理也是一个<code>Lock</code>在其所处的作用域中初始化时调用构造函数，在作用域结束时编译器调用其析构函数，这是一个C++编程上的小技巧。</p>
<p>但是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Mutex m;</span><br><span class="line">	<span class="function">Lock <span class="title">m11</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">	<span class="function">Lock <span class="title">m12</span><span class="params">(m11)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译器只能保证在<code>fun</code>的末尾肯定会插入<code>m11</code>和<code>m12</code>的构造函数，但是不能保证其顺序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Mutex::<span class="built_in">Mutex</span>(&amp;m);</span><br><span class="line"></span><br><span class="line">	Lock::<span class="built_in">Lock</span>(&amp;m11, &amp;m);</span><br><span class="line"></span><br><span class="line">	Lock::<span class="built_in">Lock</span>(*m12, &amp;m11);</span><br><span class="line"></span><br><span class="line">	Lock::~<span class="built_in">Lock</span>(&amp;m12);</span><br><span class="line"></span><br><span class="line">	Lock::~<span class="built_in">Lock</span>(&amp;m11);</span><br><span class="line"></span><br><span class="line">	Mutex::~<span class="built_in">Mutex</span>(&amp;m);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上是编译为<code>fun</code>编译产生的一种中间代码，<code>m12</code>析构比<code>m11</code>要早，但是因为<code>m12</code>没有获取到锁，因而不能释放锁，程序在这里卡死。</p>
<p>书上给出了如下的解决方法:</p>
<ol>
<li>禁止复制，这个很自然就想到了。</li>
<li>对底层资源祭出<code>引用计数法</code>，在这个例子中就更像把<code>互斥锁</code>升级为了<code>信号量</code>。</li>
<li>复制底部资源，深度复制法，但是对这个场景不适用。</li>
<li>转移地步资源拥有权。</li>
</ol>
<p>第<code>3</code>、<code>4</code>点，笔者认为是程序设计阶段的问题，对于这样的复制行为，应该作好协议，规定这类行为的代码规范。</p>
<p>因而这个条款笔者不觉得有太多可讨论的地方。</p>
<h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15:在资源管理类中提供对原始资源的访问"></a>条款15:在资源管理类中提供对原始资源的访问</h2><p>其实这个条款也是直觉上就能理解的，毕竟面向对象的编程原则不是万能的，总有不适用的场景存在，例如这个主题中经常出现的智能指针<code>shared_ptr</code>等。<code>C++11</code>智能指针提供了<code>operator-&gt;</code>的重载，也就是提供了隐式转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object* pobj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Object&gt; <span class="title">sobj</span><span class="params">(pobj)</span></span>;</span><br><span class="line"></span><br><span class="line">pobj-&gt;<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">sobj-&gt;<span class="built_in">fun</span>();</span><br></pre></td></tr></table></figure>
<p>其中<code>shared_ptr::operator-&gt;()</code>的源码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Tp* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">{</span><br><span class="line">	_GLIBCXX_DEBUG_PEDASSERT(_M_ptr != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> _M_ptr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>笔者也疑惑，这样处理之后的代码应该是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object* pobj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Object&gt; <span class="title">sobj</span><span class="params">(pobj)</span></span>;</span><br><span class="line"></span><br><span class="line">pobj-&gt;<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">(sobj::<span class="keyword">operator</span>-&gt;())<span class="built_in">fun</span>();</span><br></pre></td></tr></table></figure>
<p>中间似乎缺少了一个<code>-&gt;</code>，不过这也只能解释为语言特性了。</p>
<p>总之为了补全封装性带来的程序设计缺点，总有场景需要提取封装中的内容物，这时候只能提供原始资源访问的接口，接下来就是显式接口，如<code>Java</code>的<code>String</code>要显式地使用<code>charAt(int index)</code>来获取指定索引的字符，这样虽然不方便，但是会防止误用;而隐式接口，<code>C++</code>的<code>string</code>提供的<code>operator[](int index)</code>很方便地就符合使用者的直觉。</p>
<h2 id="条款16-成对使用new和delete时要采取相同形式"><a href="#条款16-成对使用new和delete时要采取相同形式" class="headerlink" title="条款16:成对使用new和delete时要采取相同形式"></a>条款16:成对使用new和delete时要采取相同形式</h2><p>这个条款提醒了初学者，如果用了new，那么释放的时候就用delete;如果用了new[]，就用delete[]释放。这个规则是递归使用的，如果用了多维的定义，那么就得先delete[]低一维之后才释放该维:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** matrix = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; ++row)</span><br><span class="line">{</span><br><span class="line">	matrix[row] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">10</span>; ++col)</span><br><span class="line">	{</span><br><span class="line">		matrix[row][col] = <span class="number">0</span>;		<span class="comment">// 初始化。</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">... 	<span class="comment">// 一顿操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; ++row)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">delete</span>[] matrix[row];			<span class="comment">// 释放低一维的变量。</span></span><br><span class="line">	matrix[row] = <span class="literal">nullptr</span>;			<span class="comment">// 释放完之后设置空指针是个良好的编程习惯。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] matrix;					<span class="comment">// 再释放高一维变量。</span></span><br></pre></td></tr></table></figure>
<p>这样的申请释放才不会造成内存泄漏。</p>
<p>注意书上提及的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string* stringArray = <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringArray;</span><br></pre></td></tr></table></figure>
<p>这里是用了<code>new[]</code>申请，但是用的<code>delete</code>释放，这样只会释放<code>stringArray[0]</code>。</p>
<p>注意前面也提过无论new的时候是什么形式，智能指针只会用<code>delete</code>释放资源，所以用智能指针管理资源的时候就要注意这个细节了。</p>
<h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17:以独立语句将newed对象置入智能指针"></a>条款17:以独立语句将newed对象置入智能指针</h2><p>书上给了一个例子，也提供了具体的场景，函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有如下的调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>即使有<code>智能指针</code>的辅助，仍然不能根绝<code>内存泄漏</code>的问题，试想上述调用前可能会产生如下的构造:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> <span class="built_in">Widget</span>();</span><br><span class="line"><span class="type">int</span> prio = <span class="built_in">priority</span>();</span><br><span class="line"><span class="function">std::shared_ptr <span class="title">spw</span><span class="params">(pw)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是注意上述三行代码在原代码中是处于同一行的，也就是说，如果调用<code>proirity()</code>中出现了异常，导致了<code>std::shared_ptr</code>未构造，这时候显然<code>new</code>出来的对象就逃逸了。</p>
<p>书上给出的建议，笔者认为一个是编程上的技巧，也是编程上的良好的习惯，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样就不会因为<code>priority()</code>的失败导致一个原始的<code>Widget</code>对象脱离了管理，事实上在调用一个函数的时候，也尽量简化这个调用的表达式，又有如下一个假想例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type ret_val = <span class="built_in">func</span>(</span><br><span class="line">	std::<span class="built_in">shared_ptr</span>(<span class="keyword">new</span> Object),</span><br><span class="line">	para1 == ANY_VALUE ? para1 : OTHER_VALUE,</span><br><span class="line">	<span class="built_in">func1</span>(),</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样一长串的调用，使得一个调用中的内容过于复杂，不方便后期维护审阅之外，其中任何一个参数的构造失败使得其它已经构造好的参数变得没有意义，也使对象不便于管理。</p>
<p>这个条款一个是提供编程上的小技巧，笔者认为更加像是一个良好的编程习惯。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/11/Effective-C-%E4%BA%94/" data-id="clximfz6k000f7kkv5h0t0j9v" data-title="Effective C++(五)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Effective-C-四" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/11/Effective-C-%E5%9B%9B/" class="article-date">
  <time class="dt-published" datetime="2017-12-11T07:16:08.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/11/Effective-C-%E5%9B%9B/">Effective C++(四)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="条款10-令Operator-返回一个reference-to-this"><a href="#条款10-令Operator-返回一个reference-to-this" class="headerlink" title="条款10:令Operator=返回一个reference to *this"></a>条款10:令Operator=返回一个reference to *this</h2><p>这个条款很直观，就是为了提供一个语法糖类似的功能使之可以:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = z;</span><br></pre></td></tr></table></figure>
<p>这样的连续赋值，按照惯例贴下样例实现吧:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	Object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Object&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="条款11-在operator-中处理“自我赋值”"><a href="#条款11-在operator-中处理“自我赋值”" class="headerlink" title="条款11:在operator=中处理“自我赋值”"></a>条款11:在operator=中处理“自我赋值”</h2><p>例如可能发生如下的情况:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o;</span><br><span class="line"></span><br><span class="line">o = o;</span><br></pre></td></tr></table></figure>

<p>最简单的方法就是做一次判断，如果是自己就什么都不做:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	Object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Object&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		}</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>当然书上也给出了另外一个应对异常安全的做法，就是定制一个<code>swap()</code>，这个方法会在条款29提及，以及笔者感觉特意为了这样的自我赋值做一个判断就够了。</p>
<h2 id="条款12-复制对象时切勿忘其每一个成分"><a href="#条款12-复制对象时切勿忘其每一个成分" class="headerlink" title="条款12:复制对象时切勿忘其每一个成分"></a>条款12:复制对象时切勿忘其每一个成分</h2><p>书中这个条款只是提醒了类变量成员的复制问题，而且前提是这些成员是对象成员，而不是一个指针，拥有指针时的复制就更加需要注意了。</p>
<p>先来简要介绍一下仅含对象成员:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> Base&amp; rhs) : 初始化列表</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">	Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mem1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Mem1</span>(<span class="type">const</span> Mem1&amp; rhs) : 初始化列表</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	<span class="function">Mem1&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Mem1&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mem2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Mem2</span>(<span class="type">const</span> Mem2&amp; rhs) : 初始化列表</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	<span class="function">Mem2&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Mem2&amp; rhs)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Com</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Com</span>(<span class="type">const</span> Com&amp; rhs) : <span class="built_in">Base</span>(rhs), <span class="built_in">mem1</span>(rhs.mem1), <span class="built_in">mem2</span>(rhs.mem2), ...</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	Com&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Com&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">		<span class="keyword">this</span>.mem1 = rhs.mem1;</span><br><span class="line">		<span class="keyword">this</span>.mem2 = rhs.mem2;</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mem1 mem1;</span><br><span class="line">	Mem2 mem2;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注意好复制构造函数以及赋值操作符重载基本上问题就不大了，就是编写的时候不要漏掉该处理的成员，调用基类的赋值操作符重载补全复制不到的基类成员。</p>
<p>但是当成员中存在指针的时候，就涉及到<code>深度复制</code>的问题了，设想上述的改动:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Com</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Com</span>(<span class="type">const</span> Com&amp; rhs) : <span class="built_in">Base</span>(rhs), <span class="built_in">mem1</span>(rhs.mem1), <span class="built_in">mem2</span>(rhs.mem2), ...</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	Com&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Com&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">		<span class="keyword">this</span>.mem1 = rhs.mem1;</span><br><span class="line">		<span class="keyword">this</span>.mem2 = rhs.mem2;</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	<span class="function">Mem1&amp; <span class="title">getMem1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> *mem1;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">	~<span class="built_in">Com</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">delete</span> mem1;</span><br><span class="line">		<span class="keyword">delete</span> mem2;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mem1* mem1;</span><br><span class="line">	Mem2* mem2;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>当使用该类的代码这么写:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Com* com1 = <span class="keyword">new</span> <span class="built_in">Com</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="function">Com* <span class="title">com2</span><span class="params">(com1)</span></span>; 			<span class="comment">// com2 = com1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> com1;</span><br><span class="line"></span><br><span class="line">com-&gt;<span class="built_in">getMem1</span>().调用一些Mem1的成员函数</span><br></pre></td></tr></table></figure>
<p>此时成员<code>mem1</code>和<code>mem2</code>已经被释放了，所以com2中mem1指向的是一块未定义的内存，这样的调用是十分危险的，基本上都会导致程序意外终止，所以涉及到指针的复制要更加慎重。</p>
<p>在<code>Java</code>里面，所有类的根类是<code>Object</code>，而其拥有的九个方法其中之一就是<code>clone()</code>，可惜<code>C++</code>编程太自由了，无法强制规定使用者要遵循一些编程规范。以笔者的经验来看，在<code>C++</code>里面一般涉及到深度复制的之后，也只能靠自身养成的良好的编程习惯，例如给<code>Mem1</code>类添加<code>copy()</code>或者<code>clone()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mem1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function">Mem1* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		Mem1* newObj = <span class="keyword">new</span> <span class="built_in">Mem1</span>(<span class="keyword">this</span>-&gt;{自身一些非指针型成员数据的初始化列表});</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果具有指针型的成员则递归调用其clone或者copy函数，否则在此手动深度复制</span></span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>这样定义之后，<code>Com</code>可以这样深度复制:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Com</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Com</span>(<span class="type">const</span> Com&amp; rhs) : <span class="built_in">Base</span>(rhs), <span class="built_in">mem1</span>(rhs.mem1.<span class="built_in">clone</span>()), <span class="built_in">mem2</span>(rhs.mem2.<span class="built_in">clone</span>()), ...</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	Com&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Com&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">		<span class="keyword">this</span>.mem1 = rhs.mem1.<span class="built_in">clone</span>();</span><br><span class="line">		<span class="keyword">this</span>.mem2 = rhs.mem2.<span class="built_in">clone</span>();</span><br><span class="line">		...</span><br><span class="line">	}</span><br><span class="line">	<span class="function">Mem1&amp; <span class="title">getMem1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> *mem1;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">	~<span class="built_in">Com</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">delete</span> mem1;</span><br><span class="line">		<span class="keyword">delete</span> mem2;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mem1* mem1;</span><br><span class="line">	Mem2* mem2;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>经过这样的处理，即使原来的实例已经被释放了，但是因为复制的数据是完整的，两个对象之间并没有指针引用，所以就不会造成上述的错误。</p>
<p>当然实际应用场景中也有需要对象引用相同的成员的的需求，这时候要依据具体的需求设定好接口，不过<code>clone</code>和<code>copy</code>这类函数的语义最好设定为深度复制。</p>
<p>当然使用指针之后的问题就是需要手动管理内存了，在这里暂时不展开这个话题，毕竟<code>C++</code>内存管理一直是个大问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/11/Effective-C-%E5%9B%9B/" data-id="clximfz6n000x7kkv5454b1do" data-title="Effective C++(四)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Effective-C-三" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/08/Effective-C-%E4%B8%89/" class="article-date">
  <time class="dt-published" datetime="2017-12-08T02:56:32.000Z" itemprop="datePublished">2017-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/08/Effective-C-%E4%B8%89/">Effective C++(三)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前面<a href="/2017/12/07/Effective-C-%E4%BA%8C/" title="Effective C++(二)">Effective C++(二)</a>开始讲述了<code>构造函数</code>、<code>赋值函数</code>以及<code>析构函数</code>，在讲述<code>条款5</code>时稍微展开讨论了一下细节，没想到篇幅会变长，看来之后有关<code>Effective C++</code>每篇博客的讨论的条款数量不定，只能以篇幅来限制，所以这个系列会有多少片，笔者也不清楚，碰到一些比较熟悉的条款应用就展开多讨论一些。</p>
<h2 id="条款7-为多态基类声明virtual析构函数"><a href="#条款7-为多态基类声明virtual析构函数" class="headerlink" title="条款7:为多态基类声明virtual析构函数"></a>条款7:为多态基类声明virtual析构函数</h2><p>这里涉及到面向对象中的<code>多态</code>这个性质，假设有如下继承关系，<code>Base</code>基类的析构函数为非虚函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base::~Base(this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Derived</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Derived:~Derived(this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>在析构函数中输出一些信息，有如下的<code>main</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"></span><br><span class="line">    Derived* d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"--------Stg--------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>会得到如下的输出:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base::~Base(this=0x1d04c20)</span><br><span class="line">Derived:~Derived(this=0x1d04c40)</span><br><span class="line">Base::~Base(this=0x1d04c40)</span><br><span class="line">--------Stg--------</span><br><span class="line">Base::~Base(this=0x1d04c40)</span><br><span class="line">Derived:~Derived(this=0x1d04c20)</span><br><span class="line">Base::~Base(this=0x1d04c20)</span><br></pre></td></tr></table></figure>
<p>首先看到第一个由<code>Derived</code>指针指向的对象只执行了<code>Dervied</code>自身的析构函数，随后正确执行了<code>Base</code>部分的析构。</p>
<p>然后因为上一个对象被回收了，导致下一个创建出来的对象用了上一个对象的地址，笔者在此加了一行输出隔开。用一个<code>Base</code>指针指向的<code>Derived</code>对象，其地址与上一个<code>Derived</code>对象一致，然而输出分割线下这个<code>Base</code>指向，实际为<code>Dervied</code>对象只执行<code>Base</code>部分的析构，这样就造成了<code>Derived</code>部分的内存泄漏了。</p>
<p>随后修改<code>Base</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base::~Base(this="</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>不改动<code>main</code>代码，编译执行，得到如下的输出:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base::~Base(this=0x1156c20)</span><br><span class="line">Derived:~Derived(this=0x1156c40)</span><br><span class="line">Base::~Base(this=0x1156c40)</span><br><span class="line">--------Stg--------</span><br><span class="line">Derived:~Derived(this=0x1156c40)</span><br><span class="line">Base::~Base(this=0x1156c40)</span><br><span class="line">Derived:~Derived(this=0x1156c20)</span><br><span class="line">Base::~Base(this=0x1156c20)</span><br></pre></td></tr></table></figure>
<p>第三个new出来，由<code>Base</code>指针指向的<code>Derived</code>对象正确地按照<code>Derived::~Derived()</code>、<code>Base::~Base()</code>顺序析构了这个对象。</p>
<p>虽然书上给出的心得:”只有当class内含至少一个virtual函数，才为它声明virtual析构函数”，但是笔者认为这只是一个明显的信号，在实践中，一般能够通过分析得出该类是否会被继承，这时候就可以为其声明virtual析构函数了。</p>
<p>注意<font color="red">std::string的析构函数是non-virtual的</font>，所以把std::string作为基类编写自定义类的时候是一个不明智的行为。</p>
<p>书中提到了如果一个带有纯虚析构函数的基类，其声明纯虚函数的作用是为标记此类为抽象类，但是其析构函数仍然具有行为，则可以在声明其纯虚析构函数后继续给出定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span> 		<span class="comment">// Abstract w/o Virtuals</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>()</span><br><span class="line">{}</span><br></pre></td></tr></table></figure>
<p>这样即使抽象类具有数据成员时，因其纯虚的析构函数具有定义，也可执行析构函数成功进行析构动作。</p>
<p>当一个类中带一个纯虚函数的时候，那么该类就是一个抽象类，是不可实例化的。讲到这里，笔者觉得需要与<code>Java</code>的类继承机制作为对比，<code>Java</code>只允许单继承，而允许多实现，例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FunPack1</span></span><br><span class="line">{...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FunPack2</span></span><br><span class="line">{...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied</span> <span class="keyword">extends</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">FunPack1</span>, FunPack2</span><br><span class="line">{...}</span><br></pre></td></tr></table></figure>
<p>单继承纵然会限制了语言的灵活性，多继承存在如下的问题:<br><img src="/2017/12/08/Effective-C-%E4%B8%89/inher0.jpg"></p>
<p>如果<code>~A()</code>是一个虚函数，那么一个<code>D</code>的实例被<code>delete</code>的时候其<code>A</code>部分会被析构几次？这个问题可以在对象模型中找到答案，这里就不展开细说。单继承是为了解决多继承的一些缺点，但是从<code>Java</code>多接口实现来看，事实上是多继承的功能的子集，<code>Java</code>的接口只允许声明方法的签名以及一些静态量，当用这个接口类型‘指向’其实现的对象时，则可以调用该接口声明的函数，实施一些行为。</p>
<p>笔者在此不是对比单继承多继承的优缺点，而是说明通过限制<code>C++</code>多继承可以模拟<code>Java</code>的这种方式，提供了面向对象设计的一种思路。毕竟正是因为<code>C++</code>的多样的语法导致其编程人员的上限可以很高，也可以很低，当项目集成的时候容易出现致命问题，所以在真正的<code>C++</code>项目中会事先做好一些约束。</p>
<p>也就是说，当多继承容易出问题的时候，不妨考虑约束拥有纯虚函数的基类不得拥有成员变量，使之成为一个仅仅声明纯虚函数接口的接口类，而且在后来的条款也会建议，可以用<code>组合</code>设计模式解决问题的时候就不考虑<code>继承</code>。以此为原则，基本上可以解决很多问题，起码在笔者的经历中还没碰到过非得用上述<code>菱形</code>继承的问题。</p>
<h2 id="条款8-别让异常逃离析构函数"><a href="#条款8-别让异常逃离析构函数" class="headerlink" title="条款8:别让异常逃离析构函数"></a>条款8:别让异常逃离析构函数</h2><p>相比起<code>Java</code>，<code>C++</code>在<code>异常处理</code>有着巨大的劣势，毕竟观察<code>C++</code>的发展历程，像是<code>C</code>为了跟上时代而制作的一门语言。毕竟作为一门历史比较悠久的语言，一方面要兼容<code>C</code>，一方面又不能在功能上落后于时代，就如较为前卫的<code>python</code>、<code>ruby</code>的<code>lambda</code>、<code>Duck Type</code>等语言特性，<code>C++11</code>才加入了<code>lambda</code>表达式以及<code>auto</code>关键字，而内存管理只能妥协于种种理由出了<code>memory</code>系列，<code>C++1x</code>还在探讨<code>import</code>部分导入代替现在的<code>include</code>整个文件导入。</p>
<p>说回异常，<code>Java</code>在异常发生的时候会显式地抛出异常并输出调用栈，这对于<code>debug</code>过程来说虽然信息冗长，但是花点时间审查信息的话总能筛选出有效的信息来调试程序。<code>Java</code>编译会强制要求处理一些可能抛出的异常，好一点的<code>IDE</code>会在写代码的时候就提示补全。而<code>C++</code>无论写什么都好，对于可能抛出异常的地方编译器也不会在编译期提醒。到了真正抛出异常的时候，就简单地输出一句调用”what()”的信息，没有调用栈信息，有点经验的就在很可能出现问题的代码出使用<code>gdb</code>插入断点等手段验证是不是这里出问题。</p>
<p>不过这只是强行用<code>C++</code>来做<code>面向异常的编程</code>的缺点，事实上异常是瘸腿的话，那么就不用了，大面积使用异常处理的<code>C++</code>项目确实也不常见。</p>
<p>书上介绍了场景，最后给出如下的代码方案:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		db.<span class="built_in">close</span>();</span><br><span class="line">		closed = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	~<span class="built_in">DBConn</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(!closed)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">try</span>{</span><br><span class="line">				db.<span class="built_in">close</span>();</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">catch</span>(...)</span><br><span class="line">			{</span><br><span class="line">				写log或者吞下异常。</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DBConnection db;</span><br><span class="line">	<span class="type">bool</span> closed;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样的话，析构函数只是起了用户忘记关闭连接的时候做善后处理的作用，而调用<code>db.close()</code>时候要是出问题也很大可能是在用户手动调用的时候，要是析构的时候也出异常了，证明程序或者环境配置有问题了，前提是第一次关闭的代码出异常的时候程序还能继续正常运行下去，是用户必须自己去处理的事了。</p>
<p>书上也划了个重点:</p>
<h4 id="析构函数绝对不要吐出异常。"><a href="#析构函数绝对不要吐出异常。" class="headerlink" title="析构函数绝对不要吐出异常。"></a>析构函数绝对不要吐出异常。</h4><h2 id="条款9-绝不在构造和析构过程中调用virtual函数"><a href="#条款9-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款9:绝不在构造和析构过程中调用virtual函数"></a>条款9:绝不在构造和析构过程中调用virtual函数</h2><p>这个条款很好理解，先来看看书上的例子，笔者稍微修改了一些实例代码用于演示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Transaction</span>()</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">logTransaction</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Transaction::logTransaction()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span> : <span class="keyword">public</span> Transaction{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"BuyTransaction::logTransaction()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span> : <span class="keyword">public</span> Transaction{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{...}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>当定义一个<code>BuyTransaction</code>实例时，其<code>Transaction::Transaction()</code>构造过程首先被调用，运行程序会看到输出:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transaction::logTransaction()</span><br></pre></td></tr></table></figure>
<p>查看编译器为<code>BuyTransaction</code>生成的汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction::BuyTransaction():</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    Transaction::Transaction()</span><br><span class="line">        movl    vtable for BuyTransaction+16, %edx</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movq    %rdx, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以一目了然地看到这个构造函数先调用了<code>Transaction::Transaction()</code>之后再构造<code>BuyTransaction</code>实例的<code>vtbl</code>指针，在此之前这个实例是无法获取得到<code>BuyTransaction</code>中的<code>logTransaction()</code>的地址。</p>
<p>书上给出的解决方案是将<code>logTransaction</code>的属性更改为<code>non-virtual</code>，这个是无懈可击的。但是在笔者的实际应用当中，更多的时候构造函数仅仅只是作为初始化成员变量，最多调用非成员函数用于辅助初始化成员，需要具体的操作就等使用者根据自己的需要调用，最坏的情况也只能是在构造函数中调用<code>non-virtual</code>的成员函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/08/Effective-C-%E4%B8%89/" data-id="clximfz6i00077kkve3ww69ga" data-title="Effective C++(三)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Effective-C-二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/07/Effective-C-%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2017-12-07T07:29:23.000Z" itemprop="datePublished">2017-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/07/Effective-C-%E4%BA%8C/">Effective C++(二)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一篇<a href="/2017/12/06/Effective-C-%E4%B8%80/" title="Effective C++(一)">Effective C++(一)</a>介绍了认知C++方面的内容，这一部分将讨论的是<code>构造</code>、<code>析构</code>、<code>赋值</code>方面的问题。</p>
<h2 id="条款5-了解C-默默编写并调用那些函数"><a href="#条款5-了解C-默默编写并调用那些函数" class="headerlink" title="条款5:了解C++默默编写并调用那些函数"></a>条款5:了解C++默默编写并调用那些函数</h2><p>这一条款主要是讲述C++编译器为类合成<code>构造函数</code>、<code>析构函数</code>方面的知识，其实应该结合《深度探索C++对象模型》来讲述会更加清楚，但是这一部分展开介绍实在会增加篇幅，笔者将在日后的对象模型博客中详细地介绍。</p>
<p>首先书上给的是C++编译器会如何处理空类，其中手动编写空类的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">{};</span><br></pre></td></tr></table></figure>
<p>编译器会自动生成一些成员函数，这时你的类定义可能会看起来是这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Empty</span>(){}</span><br><span class="line">	<span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs){}</span><br><span class="line">	~<span class="built_in">Empty</span>(){}</span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs){}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>只有代码中用到这一部分的函数的时候，编译器才会去处理这些成员函数。为了查看编译器是不是真的会实施这个行为，用<code>-S</code>选项并分析其生成的汇编码(<a href="/2017/11/21/%E4%BD%BF%E7%94%A8Linux%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90g-%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81/" title="使用Linux工具分析g++生成的代码">使用Linux工具分析g++生成的代码</a>)。</p>
<p>首先编写一个没有用到<code>Empty</code>的<code>main</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>查看只为<code>main</code>生成的汇编码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    %edi, -4(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>更改<code>main</code>函数为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Empty e1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>几乎也不会有什么变化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    %edi, -20(%rbp)</span><br><span class="line">        movq    %rsi, -32(%rbp)</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>只是传入到main中参数发生了一些细微的变化，并没有看到<code>构造器</code>以及<code>call</code>行为发生。</p>
<p>那将<code>main</code>改成了书上的样子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Empty e1;</span><br><span class="line"></span><br><span class="line">	<span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;</span><br><span class="line"></span><br><span class="line">	e2 = e1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>可惜的是，这样的代码也没有促使编译器合成构造器等函数，不过考虑到这本书已经有出版时间稍微有点间隔，以及笔者使用的是查看汇编码而不是其他编译器产生的中间代码，不过汇编码可以算是比其他中间代码更有证明力的部分。既然没合成，要么就是编译器已经可以针对这样的空类优化了，要么就是作者方便读者理解而设立出来的架空代码。</p>
<p>不过在此笔者继续探索，假设定义了一个类，其成员非空，先不为其编写构造函数等:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mem1;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>首先也是<code>main</code>发生上述三个行为时的时候，生成的汇编码中也没有产生成员函数，倒是<code>e2 = e1</code>时的汇编码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    %edi, -20(%rbp)</span><br><span class="line">        movq    %rsi, -32(%rbp)</span><br><span class="line">        movl    -4(%rbp), %eax			; Empty e2(e1)</span><br><span class="line">        movl    %eax, -8(%rbp)</span><br><span class="line">        movl    -4(%rbp), %eax			; e2 = e1</span><br><span class="line">        movl    %eax, -8(%rbp)</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>编译器多多少少处理了赋值行为，但是也没有明显地为其生成了一个专门的函数。</p>
<p>如果将<code>Empty</code>类的构造函数、赋值函数以及析构函数给予定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Empty</span>() : <span class="built_in">mem1</span>(<span class="number">0</span>){}</span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) : <span class="built_in">mem1</span>(rhs.mem1) {}</span><br><span class="line">        Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs)</span><br><span class="line">        {</span><br><span class="line">                mem1 = rhs.mem1;</span><br><span class="line">        }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> mem1;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>在<code>main</code>函数没有任何行为的时候，编译器也不会为这个<code>Empty</code>生成任何函数，而当开始需要构造函数的时候:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        Empty e1;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译器则为其生成了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Empty::Empty():</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    $0, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp       </span><br><span class="line">        subq    $32, %rsp</span><br><span class="line">        movl    %edi, -20(%rbp)</span><br><span class="line">        movq    %rsi, -32(%rbp)</span><br><span class="line">        leaq    -4(%rbp), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    Empty::Empty()</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        ret       </span><br></pre></td></tr></table></figure>
<p>明显地生成了该类的构造函数，也有<code>call</code>调用函数的行为，再把<code>main</code>修改:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        Empty e1;</span><br><span class="line"></span><br><span class="line">        <span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;</span><br><span class="line"></span><br><span class="line">        e2 = e1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>则生成了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Empty::Empty():</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    $0, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">Empty::Empty(Empty const&amp;):</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        movq    -16(%rbp), %rax</span><br><span class="line">        movl    (%rax), %edx</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    %edx, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">Empty::operator=(Empty const&amp;):</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        movq    %rsi, -16(%rbp)</span><br><span class="line">        movq    -16(%rbp), %rax</span><br><span class="line">        movl    (%rax), %edx</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    %edx, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        subq    $32, %rsp</span><br><span class="line">        movl    %edi, -20(%rbp)</span><br><span class="line">        movq    %rsi, -32(%rbp)</span><br><span class="line">        leaq    -4(%rbp), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    Empty::Empty()</span><br><span class="line">        leaq    -4(%rbp), %rdx</span><br><span class="line">        leaq    -8(%rbp), %rax</span><br><span class="line">        movq    %rdx, %rsi</span><br><span class="line">        leaq    -4(%rbp), %rdx</span><br><span class="line">        leaq    -8(%rbp), %rax</span><br><span class="line">        movq    %rdx, %rsi</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    Empty::Empty(Empty const&amp;)</span><br><span class="line">        leaq    -4(%rbp), %rdx</span><br><span class="line">        leaq    -8(%rbp), %rax</span><br><span class="line">        movq    %rdx, %rsi</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    Empty::operator=(Empty const&amp;)</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>在这个例子看来，现在的编译器不会默默地为类合成构造器等函数，并且是在已经使用到的情况下也只是产生了对应的行为，但是不会合成相应的函数，从某种角度来看，原书的说法还是正确的，不过要说明是编译器会合成这些行为，但是不会产生一个专门的函数，起码是在汇编码层面看不到。</p>
<h2 id="条款6-若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="条款6:若不想使用编译器自动生成的函数，就应该明确拒绝"></a>条款6:若不想使用编译器自动生成的函数，就应该明确拒绝</h2><p>书上这一条款看起来主要是针对复制构造函数以及赋值操作符，应用场景一般为禁止复制的对象。具体一些的思路就是让复制构造函数以及赋值操作附不可用，但是如果不去声明这些函数的话，编译器会自动合成这些函数。那么手动声明定义这些函数并设置其不可用状态，一般通过声明其为<code>private</code>并且不去实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">Object</span>(<span class="type">const</span> Object&amp;);</span><br><span class="line">        Object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Object&amp;);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在<code>C++11</code>下，可以这么写:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lass Object</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Object</span>(<span class="type">const</span> Object&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        Object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Object&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样就声明了这两个函数是删除并且不可用的。</p>
<p>如果实际应用中很多对象都是禁止复制的话，一般是声明一个不可复制的基类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Uncopyable</span>() {}</span><br><span class="line">        <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ~<span class="built_in">Uncopyable</span>() {}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>这样在写新的不可复制的类是就可以写:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> : <span class="keyword">private</span> Uncopyable</span><br><span class="line">{</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>那么如果使用者对该类实例进行了复制操作，编译器会尝试生成该类的复制构造函数或者赋值操作符时会以失败告终并告知编译失败。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/07/Effective-C-%E4%BA%8C/" data-id="clximfz6j000b7kkv2knp83gd" data-title="Effective C++(二)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Effective-C-一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/06/Effective-C-%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2017-12-06T07:29:56.000Z" itemprop="datePublished">2017-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/06/Effective-C-%E4%B8%80/">Effective C++(一)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Scott Meyers的<code>Effective C++</code>是C++程序员推荐的读物之一，其中充满了作者的总结出来的编程经验，当年笔者刚入门编程的时候一口气从谭浩强的《C语言编程》开始，《C Primer》、《C++ Primer Plus》等等加起来有10本书学习了如何在C++下编程。当年读这本书的时候也不具备什么具体的编程实践，除了做了书上的一些代码的实验之外，无非也就是在平时的编程中有意地使用书中的编程技巧。时至今日，笔者目前的工作虽然不是以C++来编写实践项目，像一般的<code>Web</code>项目优先考虑的是快捷的<code>Java</code>开发，但是学过的编程技巧却是跨越语言的。并且从这几年的学习编程的经验来看，真正对自己编程能力有真正提升的并不是学习了XX语言。</p>
<p>现在总结起来，笔者的编程能力有了突变式的提升是在大一下学期有一门《数据结构》，学习每种经典的数据结构时，笔者对ADT(Abstract Data Type,抽象数据类型)毫无招架之力，书中对这些经典的数据结构(栈、队列等)有一个抽象的描述，用脑子想似乎很正常，但是在具体实现时常常不知从何下手，除了一遍一遍地抄书上的代码实践之外抄到熟之外别无他法。这样下来，锻炼到遇到一个问题下来，首先是问题的分解，分解到可以直接想到这部分的代码该是什么样子的，把每个最小的部分想好之后向上整合，形成解决整个问题的具体思路。</p>
<p>到了后来实践具体项目的时候，客户的需求描述比课本的描述更加抽象，更多的是靠工程经验想像出客户的期望，也有实际的工程工具(软件开发模型等)帮助项目的一步一步实现。终归到底，依靠的还是问题分解。</p>
<p>笔者虽然已经读过了<code>Effective C++</code>，也在这几年中生搬硬套应用过书中的知识，多少都有了些心得，于是在打算在这段较为空闲的时间中写下，也算是复习这本书。</p>
<h2 id="条款1-视C-为一个语言联邦"><a href="#条款1-视C-为一个语言联邦" class="headerlink" title="条款1:视C++为一个语言联邦"></a>条款1:视C++为一个语言联邦</h2><p>书中提到了应该视C++拥有4个次语言:</p>
<ol>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ol>
<p>第1点当然很容易理解，C++兼容C的语法，并且可以直接使用C的库，但是在笔者的观点上看，使用C++更多的是为了第2点，理由稍后描述。而在笔者的编程经历上看，很少(除了用VC写C)用C++写纯C语言项目，尤其是在<code>Linux</code>下。举个<code>Socket</code>编程的例子，用<code>C</code>的话一般这么写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 做一些申请失败的处理代码，如果程序不能离开这个资源的话，甚至需要退出整个程序。</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里一小段还好，如果是写服务器端的代码的话，用到<code>bind</code>、<code>listen</code>、<code>accept</code>等函数，每次调用完之后都要判断返回值，后续还有设置其他参数等，这样的代码组织方面不会说出大的问题，但是不雅观。那么用<code>C++</code>一般是这么写的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Socket <span class="title">socket</span><span class="params">(<span class="number">8080</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然<code>Socket</code>类里面封装的代码大体还是跟原来的<code>C</code>部分相同，这里用到的是第2点中的<code>封装</code>性质，但是这里又出一个问题了，原来的<code>C</code>代码中，每一步一旦申请资源失败都可以在调用者方进行处理;进行了封装之后，中间的过程申请资源失败了，那么该怎么处理？是在本函数体内处理完异常？还是返回错误信息给调用者？如果是内部处理异常的话，那么发生了调用者不期望的行为，而调用者放心地把所有问题交给了封装好的对象，那么调用者不理会的话，程序会因为严重错误而终止运行;如果是返回错误信息给调用者的话，那么这个封装的意义何在？所以有的论调是用<code>C++</code>不如用<code>C</code>进行项目开发，除了平添开销之外没有好处，从上述的例子上看多少有点道理。但是看看隔壁的<code>Java</code>面向对象风生水起，证明了面向对象的开发可以大大提高软件的开发效率(注意是开发效率)。总之就是见仁见智吧。</p>
<p>第3点是<code>Template C++</code>，泛型编程，为了减少代码的重复而存在，例如大小的比较，总不可能一个int就写一个专门的int型比较函数，一个float型就写一个专门的float型比较函数吧。当然这只是基础的背景，事实上泛型编程有更多的应用，学习难度更高，例如泛型元编程(template metaprogramming)，然而笔者还没在应用中见识过这样的东西，一般都是做着实验玩的居多。</p>
<p>第4点是标准模板库(STL,Standard Template Library)，其实就是把经典的数据结构及其算法集成在语言基础库中，也是为了减少代码的重复，不然一个项目重新做一个轮子，这样的时间耗费基本没有意义。STL提供的库可以显著地改变代码风格，其中的<code>迭代器(Iterator)</code>是一个很重要的概念，用了STL提供的概念之后，自己实现的代码中很可能都不需要写任何算法方面的代码，也没有循环的存在，有可能两三句就把一个功能完成了。</p>
<h2 id="条款2-尽量以const-enum-inline替换-define"><a href="#条款2-尽量以const-enum-inline替换-define" class="headerlink" title="条款2:尽量以const,enum,inline替换#define"></a>条款2:尽量以const,enum,inline替换#define</h2><p>这一条款书上提供了具体的例子，<code>#define</code>定义的常量不计入符号表，到时报错的时候很可能就是一个简单的数值，这让开发者无从着手调试。而用<code>const</code>定义的常量，一是具有类型，不怕使用者错误地使用这个常量值;二是这样定义的常量记入符号表，这样编译报错起码之后错了的变量名。</p>
<p>使用<code>define</code>无法限制该变量的作用域，即便是在类中声明定义的<code>define</code>也能在全局中访问到。</p>
<p><code>enum</code>取代<code>define</code>书上没有太多的陈述，总体来说就是为了维护代码的可读性吧，加上<code>C++11</code>支持<code>class enum</code>，即强类型的<code>enum</code>。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Day</span></span><br><span class="line">{MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY};</span><br></pre></td></tr></table></figure>
<p>在<code>C++11</code>之前不能用<code>enum class</code>而用<code>enum</code>的时候，编程者可以通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Day afDay = Day::MONDAY;</span><br><span class="line"></span><br><span class="line">aDay == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>直接对比<code>Day</code>类型和<code>0</code>的值，虽然一般情况下这样第一个枚举量的值是0,但是不排除会有别的赋值，这样会导致非期望的行为，这也是编程者错误使用的一种方式。</p>
<p>而加入<code>enum class</code>之后，编译器会检查这个枚举实例的类型，如果类型不一致就会报错，从而避免而编程者的错误使用，提高了代码的可维护性。</p>
<p>当某一段代码重复出现的频率很高时，会考虑将这部分代码抽象为一个函数，例如<code>max</code>、<code>min</code>等;调用函数会产生<code>上下文切换</code>开销，当函数调用频率非常高，频繁的上下文切换开销会变得非常客观。当然现在的编译器有针对这个情况的优化，在这里暂时忽略。所以用<code>#define</code>抽象这个过程，一来可以抽象这段代码，而来又不会招致额外的开销。但是这样做也有明显的缺点，例如书中提到的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>当开始调用这个宏定义的时候:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b+<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>会被展开为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>((++a) &gt; (b) ? (++a) : (b));</span><br><span class="line"><span class="built_in">f</span>((++a) &gt; (b) ? (++a) : (b+<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>第一行因为是<code>++a</code>比较大，所以<code>++a</code>执行了两次，大概一般的程序员都不会期待这样的结果。</p>
<p>替代的方法就是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span>		<span class="comment">// 条款20</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样<code>++a</code>就不会重复两遍了。</p>
<p>注意，<code>inline</code>只是提供优化意见给编译器，编译器并不会强制执行。</p>
<h2 id="条款3-尽可能使用const"><a href="#条款3-尽可能使用const" class="headerlink" title="条款3:尽可能使用const"></a>条款3:尽可能使用const</h2><p>依笔者的经验，用<code>const</code>限制变量的修改性是比较有意义的事，这样可以很大程度地避免使用者错误地使用你提供的代码，例如在类成员函数加上<code>const</code>表示该方法不能修改该类实例中的成员变量。但是奇怪的是C++又提供了<code>mutable</code>关键字修饰成员变量，使之可以在<code>const</code>成员函数中被修改，当然这样也是因为其特殊的应用场景，毕竟应用代码的场景太多了，不能因为自己没有遇到过而否定这样的编程方式。</p>
<p>其他情况诸如<code>friend</code>友元关键字，明明声明了一个类成员是<code>private</code>，但是声明了友元之后却可以在类外部被直接访问，这样又破坏了面向对象中的封装性。但是不通过这样的编程方式的话，又难以达成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; {自定义的类实例};</span><br></pre></td></tr></table></figure>
<p>这样的语法糖。造成C++今日这种语法复杂，各种原则衍生，互相破坏的原因大概也是因为前人设计该语言的能力有限，但是也证明了通过兼容各种设计原则才能让C++支撑到今日。</p>
<p>书上关于<code>const</code>的介绍例子很多，但是笔者认为只要程序员认为该处不应该发生修改行为，就可以施用<code>const</code>语法。但是存在一个问题，一个类的成员函数作用是返回其中一个成员的引用，但是该函数用了<code>const</code>来修饰，如果调用者修改了这个引用，应该就是发生了非期望的行为。这个编程习惯应该避免。</p>
<p>另外摘抄书上一段关于<code>const</code>指针声明，毕竟这个经常让人混乱:“如果关键字const出现在星号左边，表示被指物是常量;如果出现在星号右边，表示指针自身是常量;如果出现在星号两边，表示被指物和指针两者都是常量”。</p>
<h2 id="条款4-确定对象被使用前已先被初始化"><a href="#条款4-确定对象被使用前已先被初始化" class="headerlink" title="条款4:确定对象被使用前已先被初始化"></a>条款4:确定对象被使用前已先被初始化</h2><p>其实这也是一个编程习惯上的问题，例如书上的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// getters and setters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>一般情况下声明这些变量实例的时候，这些<code>int</code>的实例会被初始化为<code>0</code>，但是显然可能发生别的值的问题，还是显式地声明初始值比较好:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> x_, <span class="type">int</span> y_)</span> : x(x_), y(y_)</span></span><br><span class="line"><span class="function">	{</span>}</span><br><span class="line"><span class="comment">//getters and setters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>加上<code>explicit</code>关键字，强迫实例必须具有初始值，这样就可以保证实例能被正确地初始化。注意示例代码中用了<code>初始化列表</code>，这个是常用的编程技巧，结合《深度探索C++对象模型》来讲述，如果用初始化列表会产生如下的构造器代码(猜测):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point::<span class="built_in">Point</span>(Point* <span class="keyword">this</span>, <span class="type">int</span> x_, <span class="type">int</span> y_)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(x_);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">y</span>(y_);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>但是如果将构造器原始代码改成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> x_, <span class="type">int</span> y_)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		x = x_;</span><br><span class="line">		y = y_;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">//getters and setters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>则可能产生如下的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Point::<span class="built_in">Point</span>(Point* <span class="keyword">this</span>, <span class="type">int</span> x_, <span class="type">int</span> y_)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">x</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">y</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;x=x_;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y=y_;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上代码仅仅作一个示例说明，在此就不详细展开了，日后笔者在写C++对象模型的博客时会提到。</p>
<p>书上还提示要记住初始化列表的顺序要与类变量在声明时的顺序保持一致。</p>
<p>这一条款中笔者比较少碰到的就是跨文件类实例初始化问题。例如<code>Point</code>中设定一个原点:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> x_, <span class="type">int</span> y_)</span> : x(x_), y(y_)</span></span><br><span class="line"><span class="function">	{</span>}</span><br><span class="line"><span class="comment">//getters and setters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> Point <span class="title">origin</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而当在外部源码文件使用到<code>origin</code>这个文件时，因为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++对“定义于不同的编译单元内的non-local static对象”的初始化相对顺序并无明确定义。</span><br></pre></td></tr></table></figure>
<p>也就是说假设使用者定义了一个二维坐标系的类实例并用到了<code>origin</code>变量时，这个二维坐标系实例已经完成了初始化，而<code>origin</code>可能尚未初始化。</p>
<p>解决这个问题用的技巧则是依赖于”C++保证函数内的local static对象会在‘该函数被调用期间’、‘首次遇上该对象之定义式’时被初始化”。转化成代码则是在原来的文件上添加:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point&amp; <span class="title">getOrigin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function"><span class="type">static</span> Point <span class="title">origin</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> origin; </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样就可以确保这个<code>origin</code>类实例可以在使用前完成初始化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/06/Effective-C-%E4%B8%80/" data-id="clximfz6h00057kkv4vxm7gat" data-title="Effective C++(一)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Eclat算法实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/12/05/Eclat%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2017-12-05T05:51:22.000Z" itemprop="datePublished">2017-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/05/Eclat%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">Eclat算法实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前实现了<a href="/2017/11/20/Apriori%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="Apriori算法实现">Apriori算法</a>以及<a href="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="FP-growth算法实现">FP-growth算法</a>，用的同一个数据集:</p>
<table>
<thead>
<tr>
<th align="center">单号</th>
<th align="center">购物清单</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T100</td>
<td align="center">I1,I2,I5</td>
</tr>
<tr>
<td align="center">T200</td>
<td align="center">I2,I4</td>
</tr>
<tr>
<td align="center">T300</td>
<td align="center">I2,I3</td>
</tr>
<tr>
<td align="center">T400</td>
<td align="center">I1,I2,I4</td>
</tr>
<tr>
<td align="center">T500</td>
<td align="center">I1,I3</td>
</tr>
<tr>
<td align="center">T600</td>
<td align="center">I2,I3</td>
</tr>
<tr>
<td align="center">T700</td>
<td align="center">I1,I3</td>
</tr>
<tr>
<td align="center">T800</td>
<td align="center">I1,I2,I3,I5</td>
</tr>
<tr>
<td align="center">T900</td>
<td align="center">I1,I2,I3</td>
</tr>
</tbody></table>
<p><code>Apriori</code>和<code>FP-growth</code>算法都是以单号为一条记录，依次读入一条这样的事务数据并进行頻数计数。</p>
<p>而<code>Eclat</code>算法主体思想是先将这样的数据做一次”转换”，直接以每条事务记录中的项为关键字，在这个样例数据中，这样的一条事务数据中的项就成为了单号。例如上述的数据集就可以转化成了:</p>
<table>
<thead>
<tr>
<th align="center">物品ID</th>
<th align="center">包含该物品的单号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I1</td>
<td align="center">T100,T400,T500,T700,T800,T900</td>
</tr>
<tr>
<td align="center">I2</td>
<td align="center">T100,T200,T300,T400,T600,T800,T900</td>
</tr>
<tr>
<td align="center">I3</td>
<td align="center">T300,T500,T600,T700,T800,T900</td>
</tr>
<tr>
<td align="center">I4</td>
<td align="center">T200,T400</td>
</tr>
<tr>
<td align="center">I5</td>
<td align="center">T100,T800</td>
</tr>
</tbody></table>
<p>这样在统计支持度的时候就可以通过计算每条记录中的元素个数了。例如在统计1-频繁项集的时候，对每条记录施以计算集合的大小，就可以得出，<code>{I1}</code>的支持度计数为6等，然后筛选。在进行2-频繁项集的时候对剩下的记录进行笛卡尔积，然后求交集的大小即可得到2-频繁项集的支持度。依次类推得到k-频繁项集的支持度计数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>读入数据部分与前面两个算法一样，采用的<a target="_blank" rel="noopener" href="http://archive.ics.uci.edu/ml/machine-learning-databases/voting-records/house-votes-84.data">样例数据</a>也一样，在此就不展开了。</p>
<p>较为关键的是数据变换的部分:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transpose_dataset</span>(<span class="params">dataset, min_sup = <span class="number">0</span></span>):</span><br><span class="line"></span><br><span class="line">    transed_dta = {}</span><br><span class="line"></span><br><span class="line">    record_idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> dataset:				<span class="comment"># 原单条的事务数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> record:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">frozenset</span>({ele}) <span class="keyword">in</span> transed_dta: 	<span class="comment"># 以原事务数据中的项为关键字查找记录</span></span><br><span class="line"></span><br><span class="line">                transed_dta[<span class="built_in">frozenset</span>({ele})].add(record_idx)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                transed_dta[<span class="built_in">frozenset</span>({ele})] = {record_idx}</span><br><span class="line"></span><br><span class="line">        record_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    qualified_data = {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> transed_dta.items():	<span class="comment"># 筛选支持度不符的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt;= min_sup:</span><br><span class="line"></span><br><span class="line">            qualified_data[k] = v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qualified_data</span><br></pre></td></tr></table></figure>

<p>后面大体的过程与<code>Apriori</code>算法差不多，不过就简单了很多:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eclat</span>(<span class="params">dataset, min_sup=<span class="number">0</span></span>):</span><br><span class="line"></span><br><span class="line">    tran_data = transpose_dataset(dataset, min_sup)	<span class="comment"># 转换数据，顺便做了1-频繁项集的筛选</span></span><br><span class="line"></span><br><span class="line">    k_sets = [tran_data]</span><br><span class="line"></span><br><span class="line">    frequent_itemsets = []</span><br><span class="line"></span><br><span class="line">    frequent_item_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rec, val <span class="keyword">in</span> tran_data.items():</span><br><span class="line"></span><br><span class="line">        frequent_item_list.append((rec, <span class="built_in">len</span>(val)))</span><br><span class="line"></span><br><span class="line">    frequent_itemsets.append(frequent_item_list.copy())</span><br><span class="line"></span><br><span class="line">    k = <span class="number">1</span>											<span class="comment"># 从2-频繁项集开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(k_sets[k - <span class="number">1</span>]) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        k_1_set = k_sets[k - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        k_set = {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k1, v1 <span class="keyword">in</span> k_1_set.items():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k2, v2 <span class="keyword">in</span> k_1_set.items():</span><br><span class="line"></span><br><span class="line">                new_key = k1.union(k2)				<span class="comment"># 由k-1频繁项集並集产生k-频繁项集</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(new_key) == (k + <span class="number">1</span>) <span class="keyword">and</span> new_key <span class="keyword">not</span> <span class="keyword">in</span> k_set:	<span class="comment"># 检查是否为k</span></span><br><span class="line"></span><br><span class="line">                    intersec = v1.intersection(v2)	<span class="comment"># 由原来两个k-1频繁项集的数据集合交集产生k频繁项集的数据集合</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(intersec) &gt;= min_sup:	<span class="comment"># 这里的支持度计数就很简单了，直接球集合的大小</span></span><br><span class="line"></span><br><span class="line">                        k_set[new_key] = intersec</span><br><span class="line"></span><br><span class="line">        frequent_item_list.clear()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> rec, val <span class="keyword">in</span> k_set.items():</span><br><span class="line"></span><br><span class="line">            frequent_item_list.append((rec, <span class="built_in">len</span>(val)))</span><br><span class="line"></span><br><span class="line">        frequent_itemsets.append(frequent_item_list.copy())	<span class="comment"># 加入结果集</span></span><br><span class="line"></span><br><span class="line">        k_sets.append(k_set)</span><br><span class="line"></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frequent_itemsets</span><br></pre></td></tr></table></figure>
<p><code>Eclat</code>的算法很简单，但是其思想启发了数据挖掘的一个新思路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/12/05/Eclat%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" data-id="clximfz6f00027kkvde6l64c1" data-title="Eclat算法实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" rel="tag">算法实现</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/" rel="tag">频繁模式挖掘</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Fedora-25配置资料整合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/11/29/Fedora-25%E9%85%8D%E7%BD%AE%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2017-11-29T00:53:10.000Z" itemprop="datePublished">2017-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/29/Fedora-25%E9%85%8D%E7%BD%AE%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/">Fedora 25配置资料整合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="WiFi热点"><a href="#WiFi热点" class="headerlink" title="WiFi热点"></a>WiFi热点</h3><p>Fedora 25直接用<code>gnome</code>的网络界面管理里面可以将无线网卡设置为热点，但是会没有响应，<a target="_blank" rel="noopener" href="http://bytefreaks.net/gnulinux/fedora-25-with-gnome-3-making-a-wi-fi-hotspot">解决办法</a>在此。</p>
<p>用<code>nm-connection-editor</code>命令打开界面，填好<code>SSID</code>，以及设置<code>Security</code>中的WiFi密码，然后回到<code>gnome</code>中的网络管理界面开启热点即可。</p>
<h3 id="Chrome中导入XX-Net的http证书无效问题"><a href="#Chrome中导入XX-Net的http证书无效问题" class="headerlink" title="Chrome中导入XX-Net的http证书无效问题"></a>Chrome中导入XX-Net的http证书无效问题</h3><p>Chrome在设置中导入了其<code>CA.crt</code>文件之后，使用http代理还是会报站点不信任问题，根据<code>Linux</code>证书管理的教程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install nss-tools		<span class="comment"># 安装证书导入工具</span></span><br></pre></td></tr></table></figure>
<p>然后导入<code>GAE</code>的证书:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ certutil -d sql:<span class="variable">$HOME</span>/.pki/nssdb -A -t TC -n <span class="string">"GoAgent XX-Net"</span> -i <span class="variable">${XX-Net的安装目录}</span>/data/gae_proxy/CA.crt</span><br></pre></td></tr></table></figure>
<p>随后无论是重启系统，还是重复导入多次还是无效。</p>
<p>有时候想查看导入的证书的信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ certutil -d sql:<span class="variable">$HOME</span>/.pki/nssdb -L</span><br></pre></td></tr></table></figure>
<p>会报:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.</span><br></pre></td></tr></table></figure>
<p>一般可能是用<code>~</code>来表示当前的用户的根目录，貌似这个<code>sql:</code>后面跟<code>~</code>会出错，用<code>$HOME</code>来代替一般可以，实在不行就只能重新建立一个库再导入了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> ~/.pki/nssdb ~/.pki/nssdb.corrupted</span><br><span class="line">$ <span class="built_in">mkdir</span> ~/.pki/nssdb</span><br><span class="line">$ <span class="built_in">chmod</span> 700 ~/.pki/nssdb</span><br><span class="line">$ certutil -d sql:<span class="variable">$HOME</span>/.pki/nssdb -N</span><br></pre></td></tr></table></figure>
<p>笔者之前搜索了好长一段时间，最后找到一个原因说是<code>Fedora 25</code>不支持<code>SSL</code>中的某个算法(具体是什么因为有点久远找不到了)，所以就算导入了证书之后也没用，以下有两个代替方案:</p>
<ol>
<li>用<code>FireFox</code>，加载插件<code>AutoProxy</code>，随后导入<code>GAE</code>证书，就可以使用<code>HTTP</code>翻墙了。</li>
<li>使用<code>XX-Net</code>中的<code>X-Tunnel</code>功能，这个协议比<code>HTTP</code>方便多了，不用导入直接使用。缺点是流量不是免费的，要么买，要么就<a target="_blank" rel="noopener" href="https://github.com/XX-net/XX-Net/wiki/DonateAppid">贡献自己的GAE</a>获得流量。</li>
</ol>
<p>之前<code>GAE</code>没墙那么紧的时候试过，还是报不信任的错误。最终笔者今天整理资料做尝试的时候，因为<code>GAE</code>的<code>IP</code>已经基本给封得扫不出来了，在启用了<code>IPv6</code>之后通过<code>HTTP</code>协议科学上网成功，这样导入证书还是有效的。</p>
<p>但是在原来的方法上无法使用时，笔者推荐使用其<code>X-Tunnel</code>功能。</p>
<h2 id="安装TIM"><a href="#安装TIM" class="headerlink" title="安装TIM"></a>安装TIM</h2><p>万恶的企鹅一直不出Linux版的通信软件，而在日常中又经常使用，但是<code>WebQQ</code>又太烂了，不好用，一般的<code>Wine QQ</code>用的是<code>2013国际版</code>，轻量版的<code>TIM</code>去除了很多不必要的功能，成为了笔者常用的通信软件，于是动了在<code>Fedora</code>下安装一个的念头。</p>
<p>笔者在多番寻找之后终于找到一个可用的<code>Fedora 25</code><a target="_blank" rel="noopener" href="https://gao4.pw/%E5%9C%A8fedora25%E4%B8%AD%E5%AE%8C%E7%BE%8Ewineqq">TIM教程</a>。</p>
<p>最后笔者在安装<code>Wine</code>重启系统之后无法进入系统，最后卸载了<code>Wine</code>才恢复了正常，所以说实在要用鹅厂软件的话，还是老老实实用虚拟机比较好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/11/29/Fedora-25%E9%85%8D%E7%BD%AE%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/" data-id="clximfz6o00187kkvg4k21i2z" data-title="Fedora 25配置资料整合" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fedora-25/" rel="tag">Fedora 25</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" rel="tag">工具配置</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux动态增删系统调用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/11/24/Linux%E5%8A%A8%E6%80%81%E5%A2%9E%E5%88%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2017-11-24T08:42:58.000Z" itemprop="datePublished">2017-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/24/Linux%E5%8A%A8%E6%80%81%E5%A2%9E%E5%88%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">Linux动态增删系统调用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="环境支持"><a href="#环境支持" class="headerlink" title="环境支持"></a>环境支持</h2><ul>
<li>Fedora 25</li>
<li>gcc</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><code>Linux</code>的系统调用是操作系统提供给用户程序调用的一组接口，用户程序可以在<code>用户态</code>下调用这些接口获得内核提供的服务，而无须进入内核态，这样就会少了很多权限上的问题，而且用户态与内核态的切换是存在开销的。</p>
<h3 id="增删系统调用的方法"><a href="#增删系统调用的方法" class="headerlink" title="增删系统调用的方法"></a>增删系统调用的方法</h3><h4 id="1-重新编译内核"><a href="#1-重新编译内核" class="headerlink" title="1.重新编译内核"></a>1.重新编译内核</h4><p>修改内核库函数的相关文件，将准备添加的系统调用声明以及实现代码等加入进去，然后使用<code>make</code>命令重新编译一个新的内核，添加到<code>grub</code>启动列表等等。</p>
<p>过程挺麻烦的，而且涉及到编译内核，要准备不少环境不说了，一旦与搜索引擎搜索出来的教程环境不一样的话，还有不小概率会编译失败。</p>
<h4 id="2-动态加载模块"><a href="#2-动态加载模块" class="headerlink" title="2.动态加载模块"></a>2.动态加载模块</h4><p>这个方法不需要修改内核库相关的文件，自己的代码源码和makefile写好，基本上就可以了。主要的原理是利用动态加载模块的时候的权限访问以及修改系统相关的一些信息。而系统调用表是操作系统级的数据，所以在动态加载的过程中获得系统调用表并修改之。</p>
<p>这个过程也不简单，而且编译成功也需要花费点心思，毕竟大多数搜出来的教程什么的，不是祖传的就是拷贝的，当自己的实验环境跟教程不一样的话，只能靠自己摸索了。</p>
<h2 id="环境参数收集"><a href="#环境参数收集" class="headerlink" title="环境参数收集"></a>环境参数收集</h2><h4 id="1-获取当前系统已使用的系统调用号"><a href="#1-获取当前系统已使用的系统调用号" class="headerlink" title="1.获取当前系统已使用的系统调用号:"></a>1.获取当前系统已使用的系统调用号:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /usr/include/asm/unistd.h</span><br></pre></td></tr></table></figure>
<p>然后根据自身系统的位数，例如笔者的<code>Fedora 25</code>是64位机:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /usr/include/asm/unistd_64.h</span><br></pre></td></tr></table></figure>
<p>获得最后一个系统调用号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_statx 332</span><br></pre></td></tr></table></figure>
<p>这样在后续设置准备添加的系统调用号就为<code>333</code>以后的值，然而这个是祖传教程里面可以采用的做法，笔者尝试了在本机64位<code>Fedora 25</code>下添加调用号为<code>333</code>的系统调用，失败了，也没能找到类似<code>NR_syscalls</code>这类的宏定义来修改。只能通过替换<code>332</code>以内的值来替换系统当前使用中的系统调用。</p>
<p>替换已有的系统调用号，在卸除自己添加的系统调用的时候还原回去。但是系统调用会被众多系统中的应用调用的，一个不小心可能会导致系统中一些应用的崩溃，所以这个是能是个实验，看来在64位机上要做应用级的系统调用还是得重新编译内核。</p>
<h4 id="2-获取系统系统调用表的内存地址"><a href="#2-获取系统系统调用表的内存地址" class="headerlink" title="2.获取系统系统调用表的内存地址:"></a>2.获取系统系统调用表的内存地址:</h4><p>解决这个问题的方法有很多，笔者采用的是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cat</span> /proc/kallsyms | grep sys_call_table</span><br></pre></td></tr></table></figure>
<p>就会得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffffffff90a00200 R sys_call_table</span><br><span class="line">ffffffff90a00e80 R ia32_sys_call_table</span><br></pre></td></tr></table></figure>
<p>只需要用到<code>sys_call_table</code>的值即可。</p>
<p>注意到它们的只读<code>R</code>属性，这意味着即使拿到了超级权限，也无法修改，怎么解决这个问题后面会提及。</p>
<h2 id="演示目标说明"><a href="#演示目标说明" class="headerlink" title="演示目标说明"></a>演示目标说明</h2><p>既然是一个实验，那肯定需要用一个演示程序及其演示结果来让实验者得知目标已达成，在这个实验里面，用户态的程序是发起系统调用，获得系统正在运行进程信息，并显示出来，在这里虽然设计了深度来表示进程是有几个前驱进程创建出来的，但是没有表现父子间的关系，只有简单的层数。</p>
<p>那么被调用的系统调用自然就是查询系统中的进程的数据结构，采集需要的数据并存到起来，返回给用户态的程序。</p>
<h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>这个结构体是用来采集系统中进程的信息，这个定义在用户态程序的代码和内核态程序的代码要分开定义，但是要保持一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process_info_t</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> process_name[TASK_COMM_LEN];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h2 id="定义准备替换的函数的功能"><a href="#定义准备替换的函数的功能" class="headerlink" title="定义准备替换的函数的功能"></a>定义准备替换的函数的功能</h2><p>定义准备替换系统调用的函数功能，注意函数参数中的<code>__user</code>定义了该参数是从用户态传入。调用<code>process_tree</code>访问系统中的进程信息并采集，随后调用<code>copy_to_user</code>函数将数据复制到用户态内存区域上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> __my_syscall__(<span class="type">char</span> __user* buf)</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	process_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	reset_proc_info_t_arr_val(pro_info_array_kernel, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Evan's system call is executing.\n"</span>);</span><br><span class="line">	</span><br><span class="line">	p = &amp;init_task;					<span class="comment">// 获得系统进程信息的表头。</span></span><br><span class="line"></span><br><span class="line">	process_tree(p, depth);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(copy_to_user((<span class="keyword">struct</span> <span class="type">process_info_t</span>*)buf, pro_info_array_kernel, <span class="number">512</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">process_info_t</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">sizeof</span>(pro_info_array_kernel);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>具体执行采集进程信息的<code>process_tree</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">process_tree</span><span class="params">(<span class="keyword">struct</span> task_struct* _p, <span class="type">int</span> _depth)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>* <span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	pro_info_array_kernel[process_counter].pid = _p-&gt;pid;</span><br><span class="line"></span><br><span class="line">	pro_info_array_kernel[process_counter].depth = _depth;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strncpy</span>(pro_info_array_kernel[process_counter].process_name, _p-&gt;comm, TASK_COMM_LEN);</span><br><span class="line"></span><br><span class="line">	++process_counter;					<span class="comment">// 全局变量，用于记录采集信息数组的下标值。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归复制子进程的信息。</span></span><br><span class="line">	<span class="keyword">for</span>(l = _p-&gt;children.next; l != &amp;(_p-&gt;children); l = l-&gt;next)</span><br><span class="line">	{</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">t</span> =</span> list_entry(l, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line"></span><br><span class="line">		process_tree(t, _depth + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="替换系统调用的函数代码"><a href="#替换系统调用的函数代码" class="headerlink" title="替换系统调用的函数代码"></a>替换系统调用的函数代码</h2><p>前面提到过系统调用表的具有不可修改的标志，甚至用超级权限也是，解决办法是用汇编访问到状态寄存器<code>CR0</code>，而<code>CR0</code>中的从低到高数20号索引(注意索引从0开始)是内存写保护位，将其设置为0之后即可为所欲为了。</p>
<p>所以思路是修改系统调用表前设置<code>CR0</code>状态，设置写保护关闭，改完表之后设回原来的值。代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭写保护的函数</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">clr_and_ret_cr0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">uint64_t</span> cr0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span>(<span class="string">"movq %%cr0, %%rax"</span>:<span class="string">"=a"</span>(cr0));					<span class="comment">// 获取CR0的值。</span></span><br><span class="line"></span><br><span class="line">	ret = cr0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cr0 &amp;= 0xfffffffffffeffff;						// 两句是等价的，设置20号位为0。</span></span><br><span class="line">    cr0 &amp;= ~<span class="number">0x10000</span>LL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span>(<span class="string">"movq %%rax, %%cr0"</span>::<span class="string">"a"</span>(cr0));					<span class="comment">// 设置CR0的值。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;											<span class="comment">// 将修改前的值返回到调用者。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复原状态的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setback_cr0</span><span class="params">(<span class="type">uint64_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"movq %%rax, %%cr0"</span>::<span class="string">"a"</span>(val))</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里用到了汇编的知识，之前的教程都是32位的汇编码，如果不加C编译参数设置编译环境是32位的话，当然在64位机编译失败。刚好笔者前一段时间科普了一下汇编，才稍微懂得把32位汇编代码改到64位机可用。</p>
<h2 id="定义加载模块时的行为"><a href="#定义加载模块时的行为" class="headerlink" title="定义加载模块时的行为"></a>定义加载模块时的行为</h2><p>修改系统调用和编写内核模块是分开两个技术范畴，只是在这个实验中借着加载以及卸载内核模块的过程修改系统调用表。前面定义了准备替换的函数行为以及修改系统写权限的代码，现在定义程序是如何实施修改系统调用表行为。</p>
<p>在加载内核模块的时候，告知系统加载模块时的行为用<code>module_init</code>，而告知系统卸载时的行为用<code>module_exit</code>。</p>
<p>加载内核模块的时候修改系统调用表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init __init_extra_syscall__(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line">	printk(<span class="string">"Evan's System call successfully added.\n"</span>);</span><br><span class="line"></span><br><span class="line">	__sys_call_table_ptr__ = (<span class="type">unsigned</span> <span class="type">long</span>*)__SYS_CALL_TABLE_ADDR__;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"System call's address: %lx. TASK_COMM_LEN's value: %d.\n"</span>, __sys_call_table_ptr__, TASK_COMM_LEN);</span><br><span class="line"></span><br><span class="line">	funptr = (<span class="type">int</span>(*)(<span class="type">void</span>)) (__sys_call_table_ptr__[__MY_SYS_CALL_NUM__]);				<span class="comment">// 保存原来表中该函数的指针。</span></span><br><span class="line"></span><br><span class="line">	orig_cr0 = clr_and_ret_cr0();														<span class="comment">// 关闭写保护。</span></span><br><span class="line"></span><br><span class="line">	__sys_call_table_ptr__[__MY_SYS_CALL_NUM__] = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;__my_syscall__;		<span class="comment">// 替换为自定义的函数。</span></span><br><span class="line"></span><br><span class="line">	setback_cr0(orig_cr0);																<span class="comment">// 复原。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>卸载内核模块的时候还原系统调用表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __exit_extra_syscall__(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line">	orig_cr0 = clr_and_ret_cr0();</span><br><span class="line"></span><br><span class="line">	__sys_call_table_ptr__[__MY_SYS_CALL_NUM__] = (<span class="type">unsigned</span> <span class="type">long</span>)funptr;</span><br><span class="line"></span><br><span class="line">	setback_cr0(orig_cr0);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Evan's system call exited.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后告知系统加载卸载内核模块行为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module_init(__init_extra_syscall__);</span><br><span class="line"></span><br><span class="line">module_exit(__exit_extra_syscall__);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>最后一句许可是不可省略的，不然会编译失败。</p>
<h2 id="用户态程序行为"><a href="#用户态程序行为" class="headerlink" title="用户态程序行为"></a>用户态程序行为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, j, err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统调用332号，并传入参数。</span></span><br><span class="line">	err = syscall(<span class="number">332</span>, &amp;processes);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Syscall result: %d.\n"</span>, err);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Syscall result: %d.\n"</span>, syscall(<span class="number">332</span>, &amp;processes));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印进程信息。</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; processes[i].depth; ++j)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"|-"</span>);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d-%s\n"</span>, processes[i].pid, processes[i].pname);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(processes[i + <span class="number">1</span>].pid == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>用户态的程序很简单，就是调用，然后显示返回的数据。</p>
<h2 id="Makefile的编写"><a href="#Makefile的编写" class="headerlink" title="Makefile的编写"></a>Makefile的编写</h2><p><code>make</code>命令已经集成好编译内核模块，指定好参数，然后<code>make</code>即可。注意<code>obj-m</code>要对应好，如笔者保存的修改系统调用表的源码文件命名为<code>ProcessTree.c</code>，所以需要<code>obj-m:=ProcessTree.o</code>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_VERSION = `uname -r`</span><br><span class="line"></span><br><span class="line"><span class="section">obj-m:=ProcessTree.o</span></span><br><span class="line"><span class="comment"># EXTRA_CFLAGS=-m32	# 在64位系统编译32位代码的标志。</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules test_run</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">	make -C /lib/modules/${KERNEL_VERSION}/build/ M=${CURDIR} modules</span><br><span class="line"></span><br><span class="line"><span class="section">test_run:</span></span><br><span class="line">	gcc -o test_run test_run.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/${KERNEL_VERSION}/build M=${CURDIR} clean; \</span><br><span class="line">	rm -rf ${CURDIR}/test_run</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/CFWLoader/Toys/tree/master/SystemCall/64bit">完整源码</a>再此。</p>
<h2 id="编译加载运行"><a href="#编译加载运行" class="headerlink" title="编译加载运行"></a>编译加载运行</h2><p>在目录下执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>即会产生目标文件，随后执行加载模块命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo insmod ProcessTree.ko</span><br></pre></td></tr></table></figure>
<p>查看加载模块信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg</span><br></pre></td></tr></table></figure>
<p>例如，在这个例子中会看到如下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[18128.569537] Evan's System call successfully added.</span><br><span class="line">[18128.569540] System call's address: ffffffffa5a00200. TASK_COMM_LEN's value: 16.</span><br></pre></td></tr></table></figure>
<p>执行用户态程序，顺利的话，会得到运行结果，输出太长了就不贴了。</p>
<p>再用<code>dmesg</code>可以看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[18158.067630] Evan's system call is executing.</span><br></pre></td></tr></table></figure>
<p>表明这个系统调用成功执行了。</p>
<p>卸载模块:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rmmod ProcessTree</span><br></pre></td></tr></table></figure>
<p>再用<code>dmesg</code>查看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[18190.508284] Evan's system call exited.</span><br></pre></td></tr></table></figure>
<p>模块卸载了，系统调用表也还原了。</p>
<p>动态修改系统调用表的尝试至此为止了。之前在用32位的代码做实验的时候挺顺利的，后来想想在64位机上理论上也可以做到同样的效果，将代码改为支持64的汇编还好。中间是卡在了之前添加系统调用的设想上，明明获取了正确的系统调用表内存地址，<code>dmesg</code>也表明修改成功了，但是在用户态调用添加的333号调用上老是报错函数未实现，但是直接替换系统当前已有的332号就可以。所以猜想系统中应该存在类似<code>NR_syscalls</code>这类变量控制好系统调用表的边界，然而动用了<code>Google</code>搜索引擎也没找到期望的结果，只能放弃了。</p>
<p>从这个实验看，<code>Linux</code>系统的安全性也越来越好了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/11/24/Linux%E5%8A%A8%E6%80%81%E5%A2%9E%E5%88%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" data-id="clximfz6q001r7kkv4s2e9rm2" data-title="Linux动态增删系统调用" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/" rel="tag">动态加载模块</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-FP-growth算法实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2017-11-23T03:20:06.000Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">FP-growth算法实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前实现了<code>Apriori</code>算法(<a href="/2017/11/20/Apriori%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="Apriori算法实现">Apriori算法实现</a>)，但是该算法存在着不少的算法性能缺陷，例如光是产生候选集都有这么多<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.777ex;" xmlns="http://www.w3.org/2000/svg" width="8.316ex" height="2.949ex" role="img" focusable="false" viewbox="0 -960 3675.6 1303.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"/></g></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="msubsup" transform="translate(2453.3,0)"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(845.3,363) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(748,-247) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>，加上用了平凡方式实现的原因，存储候选集产生了不少额外的内存使用。而<code>FP-growth</code>中的<code>FP-tree</code>则是用于压缩这些候选集的存储空间，候选集间会共享相同的元素。例如<code>{A,B,C}</code>和<code>{A,B,D}</code>，在<code>Apriori</code>中是单独的记录，而在<code>FP-growth</code>中用树存储，它们会共享<code>{A,B}</code>这个父节点，然后产生<code>{C}</code>和<code>{D}</code>两个子节点，当模式越长的时候，这种压缩方法带来的存储开销优化越明显。</p>
<p>当然为了能够构造这样的树，还要设计额外的算法构建这棵树，一旦<code>FP-tree</code>构建了起来，检索方式就特别方便了，这个例子是典型的牺牲算法复杂度换取存储复杂度的例子。</p>
<h2 id="样例数据集"><a href="#样例数据集" class="headerlink" title="样例数据集"></a>样例数据集</h2><p><code>FP-growth</code>算法过程比<code>Apriori</code>还复杂，需要用一个例子来引导学习者。这里用的是《数据挖掘概念与技术》中的例子。</p>
<table>
<thead>
<tr>
<th align="center">单号</th>
<th align="center">购物清单</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T100</td>
<td align="center">I1,I2,I5</td>
</tr>
<tr>
<td align="center">T200</td>
<td align="center">I2,I4</td>
</tr>
<tr>
<td align="center">T300</td>
<td align="center">I2,I3</td>
</tr>
<tr>
<td align="center">T400</td>
<td align="center">I1,I2,I4</td>
</tr>
<tr>
<td align="center">T500</td>
<td align="center">I1,I3</td>
</tr>
<tr>
<td align="center">T600</td>
<td align="center">I2,I3</td>
</tr>
<tr>
<td align="center">T700</td>
<td align="center">I1,I3</td>
</tr>
<tr>
<td align="center">T800</td>
<td align="center">I1,I2,I3,I5</td>
</tr>
<tr>
<td align="center">T900</td>
<td align="center">I1,I2,I3</td>
</tr>
</tbody></table>
<h2 id="生成FP-tree"><a href="#生成FP-tree" class="headerlink" title="生成FP-tree"></a>生成FP-tree</h2><p>第一步与<code>Apriori</code>一样，根据最小支持度产生<code>1</code>项集。按照上述的样例数据，可产生:</p>
<table>
<thead>
<tr>
<th align="center">项集</th>
<th align="center">支持度计数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{I1}</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">{I2}</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">{I3}</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">{I4}</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">{I5}</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>但是<code>FP-growth</code>在此开始就不产生<code>2</code>以上的候选集了。首先按照频数给频繁集排序:{I2:7, I1:6, I3:6, I4:2, I5:2}。以<code>null</code>创建<code>FP-tree</code>的根。</p>
<p>随后扫描每条事务，按照排过序的频繁集读入一条事务。例如读入<code>T100</code>将产生:<br><img src="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/fp_tree1.jpg"></p>
<p>再读入<code>T200</code>:<br><img src="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/fp_tree2.jpg"></p>
<p>这样，两条事务就共享了一个前缀<code>T2</code>，通过同样的方法，最终构建出一棵<code>FP-tree</code>:<br><img src="/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/fp_tree.jpg"></p>
<p>左边的表用于记录频繁集散布在树的位置。</p>
<p>这样生成树之后，只要从树的叶子节点开始，或者从根节点开始，只要设定好支持度阈值或其他参数，都能频繁树中获得目标模式。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">算法 FP-Growth。使用FP树，通过模式增长挖掘频繁模式。</span><br><span class="line">输入:</span><br><span class="line">	D: 事务数据库。</span><br><span class="line">	min_sup: 最小支持度阈值。</span><br><span class="line">输出:</span><br><span class="line">	频繁模式的完全集。</span><br><span class="line">方法:</span><br><span class="line">1.按以下步骤构造FP树:</span><br><span class="line">	(a)扫描事务数据库D一次。收集频繁项集的集合F和它们的支持度计数。对F按支持度计数降序排序，结果为频繁项列表L。</span><br><span class="line">	(b)创建FP树的根节点，以"null"标记它。对于D中每个事务Trans，执行:</span><br><span class="line">	   选择Trans中的频繁项，并按L中的次序排序。设Trans排序后的频繁项列表为[p|P]，其中p是第一个元素，而P是剩余元素的列表。调用insert_tree([p|P], T)。该过程执行情况如下。如果T有子女N使得N.item-name=p.item-name，则N的计数增加1;否则，创建一个新结点N，将其计数设置为1,链接到它的父结点T,并且通过结点链结构将其链接到具有相同item-name的结点。如果P非空，则递归地调用insert_tree(P,N)。</span><br><span class="line">2.FP树的挖掘通过调用FP_growth(FP_tree, null)实现。该实现过程如下。</span><br><span class="line">	procedure FP_growth(Tree, α)</span><br><span class="line">		if Tree 包含单个路径 P then</span><br><span class="line">			for 路径 P 中结点的每个组合(记作β)</span><br><span class="line">				产生模式α ∪ β，其支持度计数support_count等于β中结点的最小支持度计数;</span><br><span class="line">		else</span><br><span class="line">			for Tree的表头的每个ai</span><br><span class="line">			{</span><br><span class="line">				产生一个模式β = α ∪ ai，其支持度技术support_count=ai.support_count;</span><br><span class="line">				构造β的条件模式基，然后构造β的条件FP树Treeβ;</span><br><span class="line">				if Treeβ！=Empty Set then</span><br><span class="line">					调用FP_growth(Treeβ, β);</span><br><span class="line">			}</span><br></pre></td></tr></table></figure>

<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>先从定义<code>FpTreeNode</code>开始:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FpTreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer, node_tag=<span class="string">''</span>, val=<span class="number">0</span>, parent=<span class="literal">None</span>, child_list=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> child_list <span class="keyword">is</span> <span class="literal">None</span>:					<span class="comment"># 有不定个子结点。</span></span><br><span class="line">            child_list = []</span><br><span class="line"></span><br><span class="line">        self.layer = layer</span><br><span class="line"></span><br><span class="line">        self.node_tag = node_tag</span><br><span class="line"></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">        self.child_list = child_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increase_val</span>(<span class="params">self, inc_val=<span class="number">1</span></span>):</span><br><span class="line">        self.val += inc_val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child_node</span>(<span class="params">self, child_node</span>):</span><br><span class="line">        self.child_list.append(child_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node Name: %s, Value: %d'</span> % (self.node_tag, self.val)</span><br></pre></td></tr></table></figure>
<p>然后定义<code>FpTree</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FpTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fre_list</span>):</span><br><span class="line">        self.root = FpTreeNode(layer=<span class="number">0</span>, node_tag=<span class="string">'null'</span>)	<span class="comment"># 根结点。</span></span><br><span class="line"></span><br><span class="line">        self.fre_list = fre_list</span><br><span class="line"></span><br><span class="line">        self.lnk_tbl = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rearrange_ptn_as_fre_list</span>(<span class="params">self, ptn</span>):				<span class="comment"># 对进来的记录按照频繁集中的顺序重新排列。</span></span><br><span class="line"></span><br><span class="line">        rearranged_record = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, val) <span class="keyword">in</span> self.fre_list:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> ptn:</span><br><span class="line"></span><br><span class="line">                rearranged_record.append(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rearranged_record</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">absorb_pattern</span>(<span class="params">self, ptn, cnt</span>):						<span class="comment"># 处理进来的一条记录。</span></span><br><span class="line"></span><br><span class="line">        tree_iter = self.root</span><br><span class="line"></span><br><span class="line">        layer_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ptn = self.rearrange_ptn_as_fre_list(ptn)			<span class="comment"># 排序。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> ptn:</span><br><span class="line"></span><br><span class="line">            next_node = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> child_node <span class="keyword">in</span> tree_iter.child_list:			<span class="comment"># 查找前缀是否已存在。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> child_node.node_tag == ele:</span><br><span class="line"></span><br><span class="line">                    child_node.increase_val(cnt)			<span class="comment"># 存在则直接增加结点的计数值。</span></span><br><span class="line"></span><br><span class="line">                    next_node = child_node</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> next_node <span class="keyword">is</span> <span class="literal">None</span>:							<span class="comment"># 需要产生新的结点。</span></span><br><span class="line"></span><br><span class="line">                next_node = FpTreeNode(layer=layer_count + <span class="number">1</span>, node_tag=ele, val=cnt, parent=tree_iter)</span><br><span class="line"></span><br><span class="line">                tree_iter.add_child_node(next_node)			<span class="comment"># 增加子结点。</span></span><br><span class="line"></span><br><span class="line">            tree_iter = next_node							<span class="comment"># 进入子结点。</span></span><br><span class="line"></span><br><span class="line">            layer_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_link_tbl</span>(<span class="params">self</span>):									<span class="comment"># 产生FP树的时候，需要记录频繁集结点的分布。</span></span><br><span class="line"></span><br><span class="line">        link_tbl = {}										<span class="comment"># 以便快速检索。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, val) <span class="keyword">in</span> self.fre_list:</span><br><span class="line"></span><br><span class="line">            link_tbl[key] = [val]</span><br><span class="line"></span><br><span class="line">        queue = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.root.child_list:</span><br><span class="line"></span><br><span class="line">            queue.append(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:								<span class="comment"># BFS遍历。</span></span><br><span class="line"></span><br><span class="line">            node = queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> child_node <span class="keyword">in</span> node.child_list:</span><br><span class="line"></span><br><span class="line">                queue.append(child_node)</span><br><span class="line"></span><br><span class="line">            link_tbl[node.node_tag].append(node)			<span class="comment"># 添加结点位置记录，用item ID作为字典的关键字。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> link_tbl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_prefix_paths</span>(<span class="params">self, key, update_lnk_tbl=<span class="literal">False</span></span>):	<span class="comment"># 产生前缀路径。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.lnk_tbl <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> update_lnk_tbl:			<span class="comment"># 获得频繁集中的结点分布。</span></span><br><span class="line"></span><br><span class="line">            self.lnk_tbl = self.gen_link_tbl()</span><br><span class="line"></span><br><span class="line">        prefix_paths = {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.lnk_tbl[key][<span class="number">1</span>::]:					<span class="comment"># 链表中第一个元素是频繁集支持度，所以索引从1开始。</span></span><br><span class="line"></span><br><span class="line">            node_iter = node.parent 						<span class="comment"># 自下向上获取前缀。</span></span><br><span class="line"></span><br><span class="line">            prefix_path = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> node_iter.node_tag != <span class="string">'null'</span>:</span><br><span class="line"></span><br><span class="line">                prefix_path.add(node_iter.node_tag)</span><br><span class="line"></span><br><span class="line">                node_iter = node_iter.parent</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(prefix_path) &gt; <span class="number">0</span>: prefix_paths[<span class="built_in">frozenset</span>(prefix_path)] = node.val 	<span class="comment"># 路径的支持度是路径中的结点的最小支持度。如果路径存在频繁项，则添加到结果中。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefix_paths</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(self.root.child_list) &lt; <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>生成<code>FP-Tree</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_fp_tree</span>(<span class="params">dataset, min_sup=<span class="number">1</span></span>):</span><br><span class="line"></span><br><span class="line">    frequent_list = find_frequent_1_itemsets(dataset, min_sup)			<span class="comment"># 产生1频繁项集。</span></span><br><span class="line"></span><br><span class="line">    frequent_list = <span class="built_in">sorted</span>(frequent_list.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">1</span>], reverse=<span class="literal">True</span>)	<span class="comment"># 降序排序。</span></span><br><span class="line"></span><br><span class="line">    fp_tree = FpTree(frequent_list)										<span class="comment"># 注入到树中。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> record, cnt <span class="keyword">in</span> data_set.items():								<span class="comment"># 把事务数据注入到树中，挖掘频繁模式。</span></span><br><span class="line"></span><br><span class="line">        fp_tree.absorb_pattern(record, cnt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fp_tree</span><br></pre></td></tr></table></figure>
<p>生成了树之后，就可以调用<code>FP_growth</code>生成频繁模式了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FP_growth</span>(<span class="params">fp_tree, min_sup=<span class="number">1</span>, prefix=<span class="literal">None</span>, fre_item_list=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fre_item_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        fre_item_list = {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> prefix <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        prefix = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> base_ptn, val <span class="keyword">in</span> fp_tree.fre_list:			<span class="comment"># 自上向下扫描FP-tree。</span></span><br><span class="line"></span><br><span class="line">        new_fre_set = prefix.copy()					<span class="comment"># 前缀也按一层一层地增长。</span></span><br><span class="line"></span><br><span class="line">        new_fre_set.add(base_ptn)					<span class="comment"># 以上一层生成的前缀为基础。</span></span><br><span class="line"></span><br><span class="line">        fre_item_list[<span class="built_in">frozenset</span>(new_fre_set)] = val 	<span class="comment"># 设置该频繁项集的支持度。</span></span><br><span class="line"></span><br><span class="line">        cond_ptn_bases = fp_tree.gen_prefix_paths(base_ptn)	<span class="comment"># 生成前缀路径。</span></span><br><span class="line"></span><br><span class="line">        cond_fp_tree = gen_fp_tree(cond_ptn_bases, min_sup) <span class="comment"># 生成条件模式树。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cond_fp_tree.is_empty():						<span class="comment"># 递归子结点。</span></span><br><span class="line"></span><br><span class="line">            FP_growth(cond_fp_tree, min_sup, new_fre_set, fre_item_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fre_item_list</span><br></pre></td></tr></table></figure>
<p>代码中涉及到的数据加载以及产生<code>1</code>频繁项集的代码都与<a href="/2017/11/20/Apriori%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="Apriori算法实现">Apriori算法实现</a>一致，故本文就没有写上。</p>
<p>在这里要说明的是，在递归向下的时候，条件模式树会被不断地生成，以及生成去掉了前缀元素后的子树，因为暂时没有办法解决在不生成新的条件模式树的情况下，让下一层递归能够正确处理更新后的数据。所以笔者这里是一个可以优化的地方。</p>
<p>至此，<code>FP-growth</code>实现完毕。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cfwloader.github.io/2017/11/23/FP-growth%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" data-id="clximfz6n00107kkv8pfudr6d" data-title="FP-growth算法实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" rel="tag">算法实现</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/" rel="tag">频繁模式挖掘</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E6%8A%80%E6%9C%AF/">C++技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%8A%80%E6%9C%AF/">Java技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anderson-Darling%E6%A3%80%E9%AA%8C/" rel="tag">Anderson Darling检验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/" rel="tag">Apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C4-5/" rel="tag">C4.5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fedora-25/" rel="tag">Fedora 25</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/" rel="tag">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gems/" rel="tag">Gems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ID3/" rel="tag">ID3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaFX/" rel="tag">JavaFX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keras/" rel="tag">Keras</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kolmogorov-Smirnov%E6%A3%80%E9%AA%8C/" rel="tag">Kolmogorov Smirnov检验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%91%BD%E4%BB%A4/" rel="tag">Linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logsitic%E5%88%86%E5%B8%83/" rel="tag">Logsitic分布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MathJax/" rel="tag">MathJax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/" rel="tag">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RHEL/" rel="tag">RHEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RHEL-7-5/" rel="tag">RHEL 7.5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RailsInstaller/" rel="tag">RailsInstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime-Text-3/" rel="tag">Sublime Text 3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VC%E7%BB%B4/" rel="tag">VC维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZCA/" rel="tag">ZCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fxml/" rel="tag">fxml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/" rel="tag">gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k%E8%BF%91%E9%82%BB/" rel="tag">k近邻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A/" rel="tag">信息增益</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E6%AF%94/" rel="tag">信息增益比</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E6%A0%91/" rel="tag">分类树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/" rel="tag">动态加载模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%B7%E7%A7%AF%E5%B1%82/" rel="tag">卷积层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/" rel="tag">坐标变换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/" rel="tag">多层感知机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" rel="tag">工具配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%84%E5%90%91%E5%9F%BA%E7%BD%91%E7%BB%9C/" rel="tag">径向基网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E5%B1%82/" rel="tag">循环层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/" rel="tag">感知机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7%E6%96%B9%E6%B3%95/" rel="tag">技巧方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" rel="tag">支持向量机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" rel="tag">数学基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%B8%E5%87%BD%E6%95%B0/" rel="tag">核函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/" rel="tag">概率模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3/" rel="tag">特征分解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" rel="tag">算法实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/" rel="tag">系统运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="tag">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">练习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/" rel="tag">统计理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" rel="tag">解析几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/" rel="tag">频繁模式挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" rel="tag">高等数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Anderson-Darling%E6%A3%80%E9%AA%8C/" style="font-size: 10px;">Anderson Darling检验</a> <a href="/tags/Apache/" style="font-size: 10px;">Apache</a> <a href="/tags/C/" style="font-size: 11.43px;">C</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/C-11/" style="font-size: 18.57px;">C++11</a> <a href="/tags/C4-5/" style="font-size: 10px;">C4.5</a> <a href="/tags/Effective-C/" style="font-size: 18.57px;">Effective C++</a> <a href="/tags/Fedora-25/" style="font-size: 12.86px;">Fedora 25</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/Gems/" style="font-size: 10px;">Gems</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/ID3/" style="font-size: 10px;">ID3</a> <a href="/tags/Java/" style="font-size: 11.43px;">Java</a> <a href="/tags/JavaFX/" style="font-size: 10px;">JavaFX</a> <a href="/tags/Keras/" style="font-size: 11.43px;">Keras</a> <a href="/tags/Kolmogorov-Smirnov%E6%A3%80%E9%AA%8C/" style="font-size: 10px;">Kolmogorov Smirnov检验</a> <a href="/tags/Linux/" style="font-size: 15.71px;">Linux</a> <a href="/tags/Linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">Linux命令</a> <a href="/tags/Logsitic%E5%88%86%E5%B8%83/" style="font-size: 10px;">Logsitic分布</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MathJax/" style="font-size: 10px;">MathJax</a> <a href="/tags/R/" style="font-size: 17.14px;">R</a> <a href="/tags/RHEL/" style="font-size: 10px;">RHEL</a> <a href="/tags/RHEL-7-5/" style="font-size: 10px;">RHEL 7.5</a> <a href="/tags/RailsInstaller/" style="font-size: 10px;">RailsInstaller</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Scala/" style="font-size: 10px;">Scala</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Sublime-Text-3/" style="font-size: 10px;">Sublime Text 3</a> <a href="/tags/TCP/" style="font-size: 11.43px;">TCP</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/VC%E7%BB%B4/" style="font-size: 10px;">VC维</a> <a href="/tags/Windows/" style="font-size: 11.43px;">Windows</a> <a href="/tags/ZCA/" style="font-size: 10px;">ZCA</a> <a href="/tags/fxml/" style="font-size: 10px;">fxml</a> <a href="/tags/gdb/" style="font-size: 10px;">gdb</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/k%E8%BF%91%E9%82%BB/" style="font-size: 10px;">k近邻</a> <a href="/tags/python/" style="font-size: 12.86px;">python</a> <a href="/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A/" style="font-size: 10px;">信息增益</a> <a href="/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E6%AF%94/" style="font-size: 10px;">信息增益比</a> <a href="/tags/%E5%88%86%E7%B1%BB%E6%A0%91/" style="font-size: 10px;">分类树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/" style="font-size: 10px;">动态加载模块</a> <a href="/tags/%E5%8D%B7%E7%A7%AF%E5%B1%82/" style="font-size: 10px;">卷积层</a> <a href="/tags/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/" style="font-size: 10px;">坐标变换</a> <a href="/tags/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/" style="font-size: 12.86px;">多层感知机</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 11.43px;">学习笔记</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" style="font-size: 12.86px;">工具配置</a> <a href="/tags/%E5%BE%84%E5%90%91%E5%9F%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">径向基网络</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E5%B1%82/" style="font-size: 10px;">循环层</a> <a href="/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/" style="font-size: 10px;">感知机</a> <a href="/tags/%E6%8A%80%E5%B7%A7%E6%96%B9%E6%B3%95/" style="font-size: 10px;">技巧方法</a> <a href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" style="font-size: 10px;">支持向量机</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" style="font-size: 12.86px;">数学基础</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 12.86px;">数据挖掘</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 18.57px;">机器学习</a> <a href="/tags/%E6%A0%B8%E5%87%BD%E6%95%B0/" style="font-size: 10px;">核函数</a> <a href="/tags/%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">概率模型</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 10px;">概率论</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">深度学习</a> <a href="/tags/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3/" style="font-size: 11.43px;">特征分解</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 12.86px;">算法实现</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 10px;">系统调用</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/" style="font-size: 10px;">系统运维</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 14.29px;">线性代数</a> <a href="/tags/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.14px;">练习笔记</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" style="font-size: 11.43px;">统计学</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/" style="font-size: 10px;">统计理论</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">网络通信</a> <a href="/tags/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/" style="font-size: 10px;">解析几何</a> <a href="/tags/%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/" style="font-size: 12.86px;">频繁模式挖掘</a> <a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">高等数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/05/Git%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">Git问题汇总</a>
          </li>
        
          <li>
            <a href="/2018/12/10/%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/">逻辑斯谛回归模型</a>
          </li>
        
          <li>
            <a href="/2018/10/17/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B9%8BID3%E4%B8%8EC4-5/">决策树之ID3与C4.5</a>
          </li>
        
          <li>
            <a href="/2018/10/12/Spark%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">Spark配置笔记</a>
          </li>
        
          <li>
            <a href="/2018/08/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D/">机器学习练习笔记(九)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Evan Huang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>