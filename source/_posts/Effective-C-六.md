---
title: Effective C++(六)
date: 2017-12-18 17:12:47
tags:
	- C++
	- C++11
	- Effective C++
categories: C++技术
---

从这里开始就进入了`设计与声明`主题，这个主题是对入门者，尤其是在校的学生来说是很有用的编程建议。一来是学生项目一般小型，不需要大规模的组织;第二是没有生命周期，完成之后交付即可，所以实战项目让学生非常痛苦的事就是阅读代码，尤其是理顺逻辑。

在经历过实战项目历练之后才会知道组织代码的重要性，包括变量函数命名、写文档(简易文档也有参考性)等等，这样在日后项目有改动的时候不至于不知从何入手。笔者接触的实战项目尚少，也只能写点这样的感慨了。

## 条款18:让接口容易被正确使用，不易被误用

笔者阅读过该条款，认为该问题的主要来源是`C++`的`隐式类型转换`、`缺省参数`、`自动推导`等特性综合起来导致的。扩展开来讲的话，应该是`C++`对`类型`的管理宽松所导致的。虽然`C++`从语法上看是`强类型语言`，但是通过设置编译参数就可以跳过`类型转换`等操作，从`内存`层面来看的话更像是`弱类型语言`，如下例子:
``` c++
class A
{
public:
        int mem1;
};

class B
{
public:
        int mem1;
        float mem2;
};

int main(int argc, char* argv[])
{
        A* objA = new A;

        objA->mem1 = 3;

        B* objB = (B*)objA;

        cout << objB->mem1 << endl;

        objB->mem1 = 4;

        cout << objA->mem1 << endl;

        delete objA;

        return 0;
}
```
编译过程(即便加了`-Wall`参数)没有警告，运行得出:
``` text
3
4
```
甚至可以在违背事实的情况下，作出`objB->mem2=0.12`等操作造成难以发现的隐患。

如果同样在`Java`里面实现一样的代码的话，编译肯定是不通过的，但是这样的操作却在`C++`是允许的。这一方面为`C++`增加了不少的自由度，可以写出很灵活的代码;另一方面却给`C++`入门者一个极大的挑战，本身`指针`这个概念也难倒了不少入门者，当成功跨越这个门槛之后，却发现`指针`背后深藏更多的挑战，造成了开发调试上的困难。

(待续)