---
title: Linux动态增删系统调用
date: 2017-11-24 16:42:58
tags:
	- Linux
	- 系统调用
	- 动态加载模块
	- C
categories: 系统运维
---

## 环境支持
- Fedora 25
- gcc

## 系统调用

`Linux`的系统调用是操作系统提供给用户程序调用的一组接口，用户程序可以在`用户态`下调用这些接口获得内核提供的服务，而无须进入内核态，这样就会少了很多权限上的问题，而且用户态与内核态的切换是存在开销的。

### 增删系统调用的方法

#### 1.重新编译内核

修改内核库函数的相关文件，将准备添加的系统调用声明以及实现代码等加入进去，然后使用`make`命令重新编译一个新的内核，添加到`grub`启动列表等等。

过程挺麻烦的，而且涉及到编译内核，要准备不少环境不说了，一旦与搜索引擎搜索出来的教程环境不一样的话，还有不小概率会编译失败。

#### 2.动态加载模块

这个方法不需要修改内核库相关的文件，自己的代码源码和makefile写好，基本上就可以了。主要的原理是利用动态加载模块的时候的权限访问以及修改系统相关的一些信息。而系统调用表是操作系统级的数据，所以在动态加载的过程中获得系统调用表并修改之。

这个过程也不简单，而且编译成功也需要花费点心思，毕竟大多数搜出来的教程什么的，不是祖传的就是拷贝的，当自己的实验环境跟教程不一样的话，只能靠自己摸索了。

## 环境参数收集

#### 1.获取当前系统已使用的系统调用号:
``` bash
$ cat /usr/include/asm/unistd.h
```
然后根据自身系统的位数，例如笔者的`Fedora 25`是64位机:
``` bash
$ cat /usr/include/asm/unistd_64.h
```
获得最后一个系统调用号:
``` code
#define __NR_statx 332
```
这样在后续设置准备添加的系统调用号就为`333`以后的值。

当然也可以尝试替换已有的系统调用号，在卸除自己添加的系统调用的时候还原回去。但是系统调用会被众多系统中的应用调用的，一个不小心可能会导致系统中一些应用的崩溃，所以建议还是不要随便使用已存在的系统调用号。

#### 2.获取系统系统调用表的内存地址:

解决这个问题的方法有很多，笔者采用的是:
``` bash
$ sudo cat /proc/kallsyms | grep sys_call_table
```
就会得到:
``` code
ffffffff90a00200 R sys_call_table
ffffffff90a00e80 R ia32_sys_call_table
```
只需要用到`sys_call_table`的值即可。

注意到它们的只读`R`属性，这意味着即使拿到了超级权限，也无法修改，怎么解决这个问题后面会提及。

(待续)